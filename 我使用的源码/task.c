/* Standard includes. */
#include <stdlib.h>
#include <string.h>

/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
 * all the API functions to use the MPU wrappers.  That should only be done when
 * task.h is included from an application file. */
/*定义 MPU_WRAPPERS_INCLUDED_FROM_API_FILE 这个宏，可防止 task.h 头文件重新定义所有 API 函数以使用 MPU 包装器（MPU wrappers）。
 *只有当从应用程序文件中包含（#include）task.h 时，才应该执行（API 函数的 MPU 包装器）重新定义操作。*/
#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
#include "stack_macros.h"

/* The default definitions are only available for non-MPU ports. The
 * reason is that the stack alignment requirements vary for different
 * architectures.*/
/*默认定义仅适用于非 MPU 移植版本（non-MPU ports）。原因是不同架构（处理器架构）对栈对齐（stack alignment）的要求存在差异。*/
//configSUPPORT_STATIC_ALLOCATION == 1	启用了 FreeRTOS 的静态内存分配功能（任务 / 队列等可使用静态内存，而非动态内存 malloc）。
//configKERNEL_PROVIDED_STATIC_MEMORY == 1	要求 FreeRTOS 内核提供默认的静态内存池（即内核自动分配任务栈、TCB 的静态内存，无需用户手动定义）。
//portUSING_MPU_WRAPPERS != 0	当前是 MPU 移植版本（启用了 MPU 包装器，需适配 MPU 内存权限）。
#if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configKERNEL_PROVIDED_STATIC_MEMORY == 1 ) && ( portUSING_MPU_WRAPPERS != 0 ) )
    #error configKERNEL_PROVIDED_STATIC_MEMORY cannot be set to 1 when using an MPU port. The vApplicationGet*TaskMemory() functions must be provided manually.
#endif

#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/* 若将 configUSE_STATS_FORMATTING_FUNCTIONS 设为 2，将包含（系统状态）统计信息格式化函数，但不在此文件中包含 stdio.h 头文件。*/
#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )

/* At the bottom of this file are two optional functions that can be used
 * to generate human readable text from the raw data generated by the
 * uxTaskGetSystemState() function.  Note the formatting functions are provided
 * for convenience only, and are NOT considered part of the kernel. */
    #include <stdio.h>
#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */

#if ( configUSE_PREEMPTION == 0 )


/* 若使用协作式调度器（cooperative scheduler），则不应仅因高优先级任务被唤醒就执行任务切换（yield）。 */
    #define taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxTCB )
    #define taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB )
#else

    #if ( configNUMBER_OF_CORES == 1 )

/* 此宏请求正在运行的任务 pxTCB 执行任务切换（yield）。在单核调度器中，
 * 运行中的任务始终在 0 号核心上执行，因此可通过 portYIELD_WITHIN_API()
 * 请求 0 号核心上的任务进行切换。基于此，本宏中不使用 pxTCB 参数。 */
        #define taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxTCB ) \
    do {                                                         \
        ( void ) ( pxTCB );  /* 强制使用 pxTCB 参数，避免编译警告 */\
        portYIELD_WITHIN_API(); /* 触发当前核心（0号核）的任务切换 */\
    } while( 0 )

        #define taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB ) \
    do {                                                        \
    /* 若当前运行任务的优先级低于被唤醒任务（pxTCB）的优先级，触发任务切换 */ \
        if( pxCurrentTCB->uxPriority < ( pxTCB )->uxPriority )  \
        {                                                       \
            portYIELD_WITHIN_API(); /* 触发切换，让高优先级任务抢占运行 */\
        }                                                       \
        else                                                    \
        {                                                       \
            mtCOVERAGE_TEST_MARKER();/* 测试覆盖率标记，无实际功能 */\
        }                                                       \
    } while( 0 )

    #else /* if ( configNUMBER_OF_CORES == 1 ) */

/* 让此任务正在运行的核心执行任务切换（yield）。 */
    #define taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxTCB )    prvYieldCore( ( pxTCB )->xTaskRunState )
/
/* 若存在正在运行的任务优先级低于此任务，则为该任务触发切换。 */
    #define taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB )     prvYieldForTask( pxTCB )

    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

#endif /* if ( configUSE_PREEMPTION == 0 ) */

/* 可分配给 ucNotifyState 成员赋值的值（TCB 的成员）*/
#define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the initialised value. */ /* 必须为零，因为这是初始值。*/
#define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
#define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )

/*任务创建时用于填充任务栈的值。这一值纯粹用于检查任务的高水位线（栈使用峰值）。*/
#define tskSTACK_FILL_BYTE                        ( 0xa5U )

/* 用于记录任务的栈和 TCB（任务控制块）分配方式的位定义。 */
#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 ) // 栈和 TCB 均为动态分配
#define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 ) // 仅栈为静态分配，TCB 为动态分配
#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 ) // 栈和 TCB 均为静态分配
    
/*若以下任意一个配置项被启用（设为非零值），则任务栈会被填充为一个已知值（即 tskSTACK_FILL_BYTE），以便计算栈的高水位线（使用峰值）。*/
//configCHECK_FOR_STACK_OVERFLOW > 1	启用 “深度栈溢出检测”（FreeRTOS 提供两种栈溢出检测级别）
//configUSE_TRACE_FACILITY == 1	启用跟踪功能（用于生成系统运行轨迹，如任务切换、API 调用记录）
//INCLUDE_uxTaskGetStackHighWaterMark == 1	启用 “获取栈高水位线” 函数（uxTaskGetStackHighWaterMark()）
//INCLUDE_uxTaskGetStackHighWaterMark2 == 1	启用 “增强版栈高水位线” 函数（uxTaskGetStackHighWaterMark2()）
#if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1 // 启用栈填充
#else
    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0 // 禁用栈填充
#endif

//这些宏被 vListTask 函数用于标识任务所处的状态（以字符形式展示）
#define tskRUNNING_CHAR      ( 'X' )// 表示任务处于运行状态
#define tskBLOCKED_CHAR      ( 'B' )// 表示任务处于阻塞状态
#define tskREADY_CHAR        ( 'R' )// 表示任务处于就绪状态
#define tskDELETED_CHAR      ( 'D' )// 表示任务处于已删除状态
#define tskSUSPENDED_CHAR    ( 'S' )// 表示任务处于挂起状态

//某些支持内核感知（kernel aware）的调试器，要求其需要访问的数据是全局（global）的，而非文件作用域（file scope）的。
//未定义 portREMOVE_STATIC_QUALIFIER 时：源码为 static TCB_t *pxCurrentTCB = NULL;，pxCurrentTCB 仅在 tasks.c 文件内可见，调试器无法访问。
//定义 portREMOVE_STATIC_QUALIFIER 时：因 #define static，源码实际展开为 TCB_t *pxCurrentTCB = NULL;，pxCurrentTCB 变为全局变量，调试器可读取其值，显示当前运行任务的信息。
#ifdef portREMOVE_STATIC_QUALIFIER
    #define static
#endif

//分配给空闲任务（Idle task）的名称。可以通过在 FreeRTOSConfig.h 中定义 configIDLE_TASK_NAME 来重写此名称。
#ifndef configIDLE_TASK_NAME
    #define configIDLE_TASK_NAME    "IDLE"
#endif

#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )

/* 若 configUSE_PORT_OPTIMISED_TASK_SELECTION 为 0，则任务选择将以通用方式执行，
 * 不针对任何特定的微控制器架构架构进行优化。 */

/* uxTopReadyPriority 存储最高优先级就绪状态任务的优先级。 */
    #define taskRECORD_READY_PRIORITY( uxPriority ) \
    do {                                            \
        if( ( uxPriority ) > uxTopReadyPriority )   \
        {                                           \
            uxTopReadyPriority = ( uxPriority );    \
        }                                           \
    } while( 0 ) /* taskRECORD_READY_PRIORITY */

/*-----------------------------------------------------------*/

    #if ( configNUMBER_OF_CORES == 1 )
        #define taskSELECT_HIGHEST_PRIORITY_TASK()                                       \
    do {                                                                                 \
        UBaseType_t uxTopPriority = uxTopReadyPriority;                                  \
                                                                                         \
         /* 查找包含就绪任务的最高优先级队列。 */                                           \
        while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) != pdFALSE ) \
        {                                                                                \
            configASSERT( uxTopPriority );                                               \
            --uxTopPriority;                                                             \
        }                                                                                \
                                                                                         \
        /* listGET_OWNER_OF_NEXT_ENTRY 遍历链表，因此相同优先级的任务
         * 可以平等共享处理器时间。 */   
        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
        uxTopReadyPriority = uxTopPriority;                                                   \
    } while( 0 ) /* taskSELECT_HIGHEST_PRIORITY_TASK */
    #else /* if ( configNUMBER_OF_CORES == 1 ) */

        #define taskSELECT_HIGHEST_PRIORITY_TASK( xCoreID )    prvSelectHighestPriorityTask( xCoreID )

    #endif /* if ( configNUMBER_OF_CORES == 1 ) */

/*-----------------------------------------------------------*/

/* 取消定义 taskRESET_READY_PRIORITY() 和 portRESET_READY_PRIORITY()，
 * 因为它们仅在使用端口优化的任务选择方法时才需要。 */
    #define taskRESET_READY_PRIORITY( uxPriority )
    #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )

#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */

/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 * performed in a way that is tailored to the particular microcontroller
 * architecture being used. */

/* A port optimised version is provided.  Call the port defined macros. */
    #define taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( ( uxPriority ), uxTopReadyPriority )

/*-----------------------------------------------------------*/

    #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
    do {                                                                                        \
        UBaseType_t uxTopPriority;                                                              \
                                                                                                \
        /* Find the highest priority list that contains ready tasks. */                         \
        portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
        configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
    } while( 0 )

/*-----------------------------------------------------------*/

/* A port optimised version is provided, call it only if the TCB being reset
 * is being referenced from a ready list.  If it is referenced from a delayed
 * or suspended list then it won't be in a ready list. */
    #define taskRESET_READY_PRIORITY( uxPriority )                                                     \
    do {                                                                                               \
        if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 ) \
        {                                                                                              \
            portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                        \
        }                                                                                              \
    } while( 0 )

#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */

/*-----------------------------------------------------------*/

/* 当节拍计数（tick count）溢出时，pxDelayedTaskList 和 pxOverflowDelayedTaskList 会进行切换。 */
#define taskSWITCH_DELAYED_LISTS()                                                \
    do {                                                                          \
        List_t * pxTemp;                                                          \
                                                                                  \
        /* The delayed tasks list should be empty when the lists are switched. */ \
        /* 当链表切换时，延迟任务链表（pxDelayedTaskList）应为空。 */                 \
        configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
                                                                                  \
        pxTemp = pxDelayedTaskList;                                               \
        pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
        pxOverflowDelayedTaskList = pxTemp;                                       \
        xNumOfOverflows = ( BaseType_t ) ( xNumOfOverflows + 1 );/*更新溢出计数*/  \
        prvResetNextTaskUnblockTime();                /*重置下一次唤醒时间 */       \
    } while( 0 )

/*-----------------------------------------------------------*/

/* 将 pxTCB 所代表的任务放入该任务对应的就绪链表中。插入到链表的末尾。 */
#define prvAddTaskToReadyList( pxTCB )                                     \
    do {                                                                   \
        traceMOVED_TASK_TO_READY_STATE( pxTCB );                           \
        /* 调试跟踪宏（仅在启用 configUSE_TRACE_FACILITY 时有效），记录 “任务进入就绪状态” 的事件，用于调试工具（如可视化调度器）展示状态变化。*/
        taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                \
        /* 更新最高就绪优先级 */
        listINSERT_END( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );   /* 插入任务到就绪链表 */                                              \
        tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB );                      \
        /*跟踪任务进入就绪状态后*/
    } while( 0 )
/*-----------------------------------------------------------*/


/*有几个函数接受一个 TaskHandle_t 类型的参数，该参数可以选择为 NULL，
其中 NULL 用于表示应使用当前正在执行的任务的句柄来替代该参数。
这个宏只是检查该参数是否为 NULL，并返回一个指向相应 TCB（任务控制块）的指针。*/
#define prvGetTCBFromHandle( pxHandle )    ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )

/*事件链表项的 item value（项值）通常用于保存其所属任务的优先级（经过编码以允许按反向优先级顺序存储）。
然而，它偶尔会被借用于其他目的。重要的是，当它被用于其他目的时，不应因任务优先级变化而更新其值。
以下位定义用于通知调度器该值不应被修改 —— 在这种情况下，使用该值的模块有责任确保在释放时将其设置回原始值。*/
#if ( configTICK_TYPE_WIDTH_IN_BITS == TICK_TYPE_WIDTH_16_BITS )
    #define taskEVENT_LIST_ITEM_VALUE_IN_USE    ( ( uint16_t ) 0x8000U )
#elif ( configTICK_TYPE_WIDTH_IN_BITS == TICK_TYPE_WIDTH_32_BITS )
    #define taskEVENT_LIST_ITEM_VALUE_IN_USE    ( ( uint32_t ) 0x80000000U )
#elif ( configTICK_TYPE_WIDTH_IN_BITS == TICK_TYPE_WIDTH_64_BITS )
    #define taskEVENT_LIST_ITEM_VALUE_IN_USE    ( ( uint64_t ) 0x8000000000000000U )
#endif

/* 表示任务未在任何核心上活跃运行。 */
#define taskTASK_NOT_RUNNING           ( ( BaseType_t ) ( -1 ) )

/* 表示任务正在活跃运行（但已调度为让出 CPU）。 */
#define taskTASK_SCHEDULED_TO_YIELD    ( ( BaseType_t ) ( -2 ) )

/* 如果任务正在活跃运行且未被调度让出CPU，则返回pdTRUE。 */
#if ( configNUMBER_OF_CORES == 1 )
    #define taskTASK_IS_RUNNING( pxTCB )                          ( ( ( pxTCB ) == pxCurrentTCB ) ? ( pdTRUE ) : ( pdFALSE ) )
    #define taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB )    ( ( ( pxTCB ) == pxCurrentTCB ) ? ( pdTRUE ) : ( pdFALSE ) )
#else
    #define taskTASK_IS_RUNNING( pxTCB )                          ( ( ( ( pxTCB )->xTaskRunState >= ( BaseType_t ) 0 ) && ( ( pxTCB )->xTaskRunState < ( BaseType_t ) configNUMBER_OF_CORES ) ) ? ( pdTRUE ) : ( pdFALSE ) )
    #define taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB )    ( ( ( pxTCB )->xTaskRunState != taskTASK_NOT_RUNNING ) ? ( pdTRUE ) : ( pdFALSE ) )
#endif

/* 表示该任务是空闲任务（Idle task）。 */
#define taskATTRIBUTE_IS_IDLE    ( UBaseType_t ) ( 1U << 0U )

//configNUMBER_OF_CORES > 1：系统为多核（SMP）架构；
//portCRITICAL_NESTING_IN_TCB == 1：移植层配置为 “临界区嵌套计数存储在 TCB 中”（而非全局变量）。
#if ( ( configNUMBER_OF_CORES > 1 ) && ( portCRITICAL_NESTING_IN_TCB == 1 ) )
    #define portGET_CRITICAL_NESTING_COUNT()          ( pxCurrentTCBs[ portGET_CORE_ID() ]->uxCriticalNesting )
    #define portSET_CRITICAL_NESTING_COUNT( x )       ( pxCurrentTCBs[ portGET_CORE_ID() ]->uxCriticalNesting = ( x ) )
    #define portINCREMENT_CRITICAL_NESTING_COUNT()    ( pxCurrentTCBs[ portGET_CORE_ID() ]->uxCriticalNesting++ )
    #define portDECREMENT_CRITICAL_NESTING_COUNT()    ( pxCurrentTCBs[ portGET_CORE_ID() ]->uxCriticalNesting-- )
#endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( portCRITICAL_NESTING_IN_TCB == 1 ) ) */

#define taskBITS_PER_BYTE    ( ( size_t ) 8 )

#if ( configNUMBER_OF_CORES > 1 )

/* Yields the given core. This must be called from a critical section and xCoreID
 * must be valid. This macro is not required in single core since there is only
 * one core to yield. */
    #define prvYieldCore( xCoreID )                                                          \
    do {                                                                                     \
        if( ( xCoreID ) == ( BaseType_t ) portGET_CORE_ID() )                                \
        {                                                                                    \
            /* Pending a yield for this core since it is in the critical section. */         \
            xYieldPendings[ ( xCoreID ) ] = pdTRUE;                                          \
        }                                                                                    \
        else                                                                                 \
        {                                                                                    \
            /* Request other core to yield if it is not requested before. */                 \
            if( pxCurrentTCBs[ ( xCoreID ) ]->xTaskRunState != taskTASK_SCHEDULED_TO_YIELD ) \
            {                                                                                \
                portYIELD_CORE( xCoreID );                                                   \
                pxCurrentTCBs[ ( xCoreID ) ]->xTaskRunState = taskTASK_SCHEDULED_TO_YIELD;   \
            }                                                                                \
        }                                                                                    \
    } while( 0 )
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

/*
 * 任务控制块（Task Control Block）。每个任务都会分配一个任务控制块（TCB），
 * 用于存储任务的状态信息，包括指向任务上下文的指针（任务的运行时环境，包括寄存器值）。
 */
typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel aware debuggers. */
{
	/**< 指向任务栈中最后放入的项的位置。这必须是TCB结构体的第一个成员。 */
    volatile StackType_t * pxTopOfStack; /**< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */

    #if ( portUSING_MPU_WRAPPERS == 1 )
		/**< MPU设置由移植层定义。这必须是TCB结构体的第二个成员。 */
        xMPU_SETTINGS xMPUSettings; /**< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    #endif

    #if ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 )
		/**< 用于将任务与特定核心关联。UBaseType_t的位数必须大于或等于configNUMBER_OF_CORES。 */
        UBaseType_t uxCoreAffinityMask; /**< Used to link the task to certain cores.  UBaseType_t must have greater than or equal to the number of bits as configNUMBER_OF_CORES. */
    #endif

    ListItem_t xStateListItem;                  /**< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
	/**< 任务的状态链表项所引用的链表表示该任务的状态（就绪、阻塞、挂起）。 */
    ListItem_t xEventListItem;                  /**< Used to reference a task from an event list. */
	/**< 用于从事件链表中引用任务。 */
    UBaseType_t uxPriority;                     /**< The priority of the task.  0 is the lowest priority. */
	/**< 任务的优先级。0是最低优先级。 */
    StackType_t * pxStack;                      /**< Points to the start of the stack. */
    /**< 指向栈的起始位置。 */
    
    #if ( configNUMBER_OF_CORES > 1 )
        volatile BaseType_t xTaskRunState;      /**< Used to identify the core the task is running on, if the task is running. Otherwise, identifies the task's state - not running or yielding. */
    	/**< 用于标识任务正在运行的核心（如果任务正在运行）。否则，标识任务的状态——未运行或正在让出CPU。 */
        UBaseType_t uxTaskAttributes;           /**< Task's attributes - currently used to identify the idle tasks. */
    	/**< 任务的属性——当前用于标识空闲任务。 */
    #endif
    char pcTaskName[ configMAX_TASK_NAME_LEN ]; /**< Descriptive name given to the task when created.  Facilitates debugging only. */
	/**< 创建任务时赋予的描述性名称。仅用于调试。 */

    #if ( configUSE_TASK_PREEMPTION_DISABLE == 1 )
        BaseType_t xPreemptionDisable; /**< Used to prevent the task from being preempted. */
    	/**< 用于防止任务被抢占。 */
    #endif

    #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
        StackType_t * pxEndOfStack; /**< Points to the highest valid address for the stack. */
    	/**< 指向栈的最高有效地址。 */
    #endif

    #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        UBaseType_t uxCriticalNesting; /**< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    	/**< 用于在移植层不维护自己的计数的端口中，保存临界区嵌套深度。 */
    #endif

    #if ( configUSE_TRACE_FACILITY == 1 )
        UBaseType_t uxTCBNumber;  /**< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    	/**< 存储每次创建TCB时递增的数字。允许调试器确定任务何时被删除然后重新创建。 */
        UBaseType_t uxTaskNumber; /**< Stores a number specifically for use by third party trace code. */
    	/**< 专门存储供第三方跟踪代码使用的数字。 */
    #endif

    #if ( configUSE_MUTEXES == 1 )
        UBaseType_t uxBasePriority; /**< The priority last assigned to the task - used by the priority inheritance mechanism. */
    	 /**< 上次分配给任务的优先级——用于优先级继承机制。 */
        UBaseType_t uxMutexesHeld;
    #endif

    #if ( configUSE_APPLICATION_TASK_TAG == 1 )
        TaskHookFunction_t pxTaskTag;
    #endif

    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
        void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    #endif

    #if ( configGENERATE_RUN_TIME_STATS == 1 )
        configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /**< Stores the amount of time the task has spent in the Running state. */
    	/**< 存储任务在运行状态所花费的时间。 */
    #endif

    #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
        configTLS_BLOCK_TYPE xTLSBlock; /**< Memory block used as Thread Local Storage (TLS) Block for the task. */
    	/**< 用作任务的线程本地存储（TLS）块的内存块。 */
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
        volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    #endif

    /* See the comments in FreeRTOS.h with the definition of
     * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
    #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
        uint8_t ucStaticallyAllocated; /**< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
    	/**< 如果任务是静态分配的，则设置为pdTRUE，以确保不会尝试释放该内存。 */
    #endif

    #if ( INCLUDE_xTaskAbortDelay == 1 )
        uint8_t ucDelayAborted;
    #endif

    #if ( configUSE_POSIX_ERRNO == 1 )
        int iTaskErrno;
    #endif
} tskTCB;

/* 上面保留了旧的tskTCB名称，然后在下面将其重定义为新的TCB_t名称，
 * 以支持较旧的内核感知调试器。 */
typedef tskTCB TCB_t;

#if ( configNUMBER_OF_CORES == 1 )
    /* MISRA Ref 8.4.1 [Declaration shall be visible] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-84 */
    /* coverity[misra_c_2012_rule_8_4_violation] */
    portDONT_DISCARD PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
#else
    /* MISRA Ref 8.4.1 [Declaration shall be visible] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-84 */
    /* coverity[misra_c_2012_rule_8_4_violation] */
    portDONT_DISCARD PRIVILEGED_DATA TCB_t * volatile pxCurrentTCBs[ configNUMBER_OF_CORES ];
    #define pxCurrentTCB    xTaskGetCurrentTaskHandle()
#endif


/* 就绪和阻塞任务的链表。--------------------
 * xDelayedTaskList1 和 xDelayedTaskList2 本可以移至函数作用域，但
 * 这样做会破坏一些支持内核感知的调试器以及依赖移除 static 限定符的调试器。 */
PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /**< Prioritised ready tasks. */
/**< 按优先级排序的就绪任务。 */
PRIVILEGED_DATA static List_t xDelayedTaskList1;                         /**< Delayed tasks. */
/**< 延迟任务链表。 */
PRIVILEGED_DATA static List_t xDelayedTaskList2;                         /**< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
/**< 延迟任务链表（使用两个链表 - 一个用于已溢出当前节拍计数的延迟任务）。 */
PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              /**< Points to the delayed task list currently being used. */
/**< 指向当前正在使用的延迟任务链表。 */
PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      /**< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
 /**< 指向当前用于存放已溢出当前节拍计数的任务的延迟任务链表。 */
PRIVILEGED_DATA static List_t xPendingReadyList;                         /**< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
/**< 调度器挂起时被就绪的任务。它们将在调度器恢复时移至就绪链表。 */

#if ( INCLUDE_vTaskDelete == 1 )

    PRIVILEGED_DATA static List_t xTasksWaitingTermination; /**< Tasks that have been deleted - but their memory not yet freed. */
	/**< 已被删除但内存尚未释放的任务链表。 */
    PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;

#endif

#if ( INCLUDE_vTaskSuspend == 1 )

    PRIVILEGED_DATA static List_t xSuspendedTaskList; /**< Tasks that are currently suspended. */
	/**< 当前处于挂起状态的任务链表。 */
#endif

/* Global POSIX errno. Its value is changed upon context switching to match
 * the errno of the currently running task. */
/* 全局 POSIX 标准 errno。其值会在上下文切换时更新，以匹配当前运行任务的 errno。 */
#if ( configUSE_POSIX_ERRNO == 1 )
    int FreeRTOS_errno = 0;
#endif

/* Other file private variables. --------------------------------*/
/* 其他文件私有变量。--------------------------------*/
PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
/*记录系统当前存在的总任务数（包括就绪、阻塞、挂起、空闲任务）*/
PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
/*记录系统从启动到当前的总节拍数（每触发一次 SysTick 中断，此值递增 1）*/
PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
/*记录系统中最高优先级的就绪任务优先级*/
PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
/*标记调度器的运行状态。*/
PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
/*记录 xTickCount 的溢出次数。*/
PRIVILEGED_DATA static volatile BaseType_t xYieldPendings[ configNUMBER_OF_CORES ] = { pdFALSE };
/*记录每个核心上 “是否有任务切换请求（Yield）挂起”*/
PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
/*暂存 “在临界区或调度器挂起期间应递增的节拍数”。*/
PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
/*为每个新创建的任务分配唯一序号（任务创建时自动递增）*/
PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
/*记录下一个延迟任务需要被唤醒的节拍时间。*/
/* 调度器启动前会初始化为 portMAX_DELAY。 */
PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandles[ configNUMBER_OF_CORES ];       /**< Holds the handles of the idle tasks.  The idle tasks are created automatically when the scheduler is started. */
/*存储每个核心对应的空闲任务句柄。*/
/**< 存储空闲任务的句柄。空闲任务在调度器启动时自动创建。 */

/* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
 * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority
 * to determine the number of priority lists to read back from the remote target. */
/* 改进对 OpenOCD 的支持。内核通过优先级链表跟踪就绪任务。
 * 为了跟踪远程线程的状态，OpenOCD 使用 uxTopUsedPriority 
 * 来确定需要从远程目标回读的优先级链表数量。 */
static const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;

/* 调度器挂起期间，任务切换请求会被挂起。此外，
 * 若调度器处于挂起状态，中断不得操作任务控制块（TCB）的 xStateListItem，
 * 也不得操作 xStateListItem 可能引用的任何链表。
 * 若中断在调度器挂起期间需要解除任务阻塞，则需将任务的事件链表项（xEventListItem）
 * 移至 xPendingReadyList（挂起就绪链表）；当调度器恢复时，内核会将任务从挂起就绪链表
 * 移至实际的就绪链表。挂起就绪链表本身仅能在临界区中访问。
 *
 * 对 uxSchedulerSuspended 的修改必须同时受任务锁和 ISR 锁保护，且不得在 ISR（中断服务函数）中执行。
 * 对 uxSchedulerSuspended 的读取必须受任一锁（任务锁或 ISR 锁）保护，且可在 ISR 或任务中执行。 */
PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) 0U;

#if ( configGENERATE_RUN_TIME_STATS == 1 )

/* Do not move these variables to function scope as doing so prevents the
 * code working with debuggers that need to remove the static qualifier. */
/* 不要将这些变量移至函数作用域，否则会导致代码无法与需要移除 static 限定符的调试器配合工作。 */
PRIVILEGED_DATA static configRUN_TIME_COUNTER_TYPE ulTaskSwitchedInTime[ configNUMBER_OF_CORES ] = { 0U };    /**< Holds the value of a timer/counter the last time a task was switched in. */
PRIVILEGED_DATA static volatile configRUN_TIME_COUNTER_TYPE ulTotalRunTime[ configNUMBER_OF_CORES ] = { 0U }; /**< Holds the total amount of execution time as defined by the run time counter clock. */

#endif

/*-----------------------------------------------------------*/

/* File private functions. --------------------------------*/

/*
 * Creates the idle tasks during scheduler start.
 */
/*在调度器启动期间创建空闲任务。*/
static BaseType_t prvCreateIdleTasks( void );

#if ( configNUMBER_OF_CORES > 1 )

/*
 * Checks to see if another task moved the current task out of the ready
 * list while it was waiting to enter a critical section and yields, if so.
 */
/*检查是否有其他任务在当前任务等待进入临界区时将其移出就绪链表，
 *若是，则执行任务让出（yield）操作。*/
    static void prvCheckForRunStateChange( void );
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */

#if ( configNUMBER_OF_CORES > 1 )

/*
 * Yields a core, or cores if multiple priorities are not allowed to run
 * simultaneously, to allow the task pxTCB to run.
 */
/*让出一个或多个核心（如果不允许多任务可以同时运行），以允许任务 pxTCB 运行*/
    static void prvYieldForTask( const TCB_t * pxTCB );
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */

#if ( configNUMBER_OF_CORES > 1 )

/*
 * Selects the highest priority available task for the given core.
 */
/*为指定核心选择优先级最高的可用任务。*/
    static void prvSelectHighestPriorityTask( BaseType_t xCoreID );
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */

/**
 * Utility task that simply returns pdTRUE if the task referenced by xTask is
 * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 * is in any other state.
 */
/*工具函数，若 xTask 所引用的任务当前处于挂起状态则返回 pdTRUE，
 *若 xTask 所引用的任务处于其他任何状态则返回 pdFALSE。*/
#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;

#endif /* INCLUDE_vTaskSuspend */

/*Utility to ready all the lists used by the scheduler.  This is called automatically upon the creation of the first task.*/
/*用于初始化调度器所使用的所有链表的工具函数。此函数会在第一个任务创建时自动调用。*/
static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;

/*
 * The idle task, which as all tasks is implemented as a never ending loop.
 * The idle task is automatically created and added to the ready lists upon
 * creation of the first user task.
 *
 * In the FreeRTOS SMP, configNUMBER_OF_CORES - 1 passive idle tasks are also
 * created to ensure that each core has an idle task to run when no other
 * task is available to run.
 *
 * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 * language extensions.  The equivalent prototype for these functions are:
 *
 * void prvIdleTask( void *pvParameters );
 * void prvPassiveIdleTask( void *pvParameters );
 *
 */
/*
 * 空闲任务，和所有任务一样，以一个永不结束的循环实现。
 * 空闲任务在第一个用户任务创建时被自动创建并加入就绪链表。
 *
 * 在 FreeRTOS SMP 中，还会创建 configNUMBER_OF_CORES - 1 个被动空闲任务，
 * 以确保当没有其他任务可运行时，每个核心都有一个空闲任务可运行。
 *
 * portTASK_FUNCTION_PROTO() 宏用于支持特定于端口/编译器的语言扩展。
 * 这些函数的等效原型是：
 *
 * void prvIdleTask( void *pvParameters );
 * void prvPassiveIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
#if ( configNUMBER_OF_CORES > 1 )
    static portTASK_FUNCTION_PROTO( prvPassiveIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
#endif

/*
 * Utility to free all memory allocated by the scheduler to hold a TCB,
 * including the stack pointed to by the TCB.
 *
 * This does not free memory allocated by the task itself (i.e. memory
 * allocated by calls to pvPortMalloc from within the tasks application code).
 */
/*
 * 用于释放调度器为存储TCB所分配的所有内存，包括TCB所指向的栈内存。
 * 此函数不会释放任务自身分配的内存（即任务应用代码中通过pvPortMalloc调用分配的内存）。
 */
#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;

#endif

/*
 * Used only by the idle task.  This checks to see if anything has been placed
 * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 * and its TCB deleted.
 */
/*
 * 仅由空闲任务使用。该函数检查等待删除的任务链表（xTasksWaitingTermination）中是否存在任务。
 * 若存在，则对任务进行清理并删除其TCB。
 */
static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;

/*
 * The currently executing task is entering the Blocked state.  Add the task to
 * either the current or the overflow delayed task list.
 */
/*
 * 当前正在执行的任务将进入阻塞状态。将该任务添加到当前延迟任务链表（pxDelayedTaskList）
 * 或溢出延迟任务链表（pxOverflowDelayedTaskList）中。
 */
static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;

/*
 * Fills an TaskStatus_t structure with information on each task that is
 * referenced from the pxList list (which may be a ready list, a delayed list,
 * a suspended list, etc.).
 *
 * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 * NORMAL APPLICATION CODE.
 */
/*
 * 遍历 pxList 链表（可能是就绪链表、延迟链表、挂起链表等）中引用的每个任务，
 * 并将任务信息填充到 TaskStatus_t 结构体中。
 *
 * 此函数仅用于调试目的，不应从正常应用代码中调用。
 */
#if ( configUSE_TRACE_FACILITY == 1 )

    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                     List_t * pxList,
                                                     eTaskState eState ) PRIVILEGED_FUNCTION;

#endif

/*
 * Searches pxList for a task with name pcNameToQuery - returning a handle to
 * the task if it is found, or NULL if the task is not found.
 */
/*
 * 在 pxList 链表中搜索名称为 pcNameToQuery 的任务——如果找到则返回该任务的句柄，
 * 如果未找到则返回 NULL。
 */
#if ( INCLUDE_xTaskGetHandle == 1 )

    static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
                                                     const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;

#endif

/*
 * When a task is created, the stack of the task is filled with a known value.
 * This function determines the 'high water mark' of the task stack by
 * determining how much of the stack remains at the original preset value.
 */
/*
 * 当任务创建时，任务的栈会被填充一个已知值。
 * 此函数通过判断栈中剩余多少原始预设值，来确定任务栈的"高水位线"（即栈的最小剩余空间）。
 */
#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;

#endif

/*
 * Return the amount of time, in ticks, that will pass before the kernel will
 * next move a task from the Blocked state to the Running state.
 *
 * This conditional compilation should use inequality to 0, not equality to 1.
 * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 * set to a value other than 1.
 */
/*
 * 返回从当前时刻起，在内核下次将任务从阻塞状态迁移到运行状态之前，
 * 将要经过的节拍数。
 *
 * 此条件编译应使用不等于0的判断，而非等于1的判断。
 * 这是为了确保当用户定义的低功耗模式实现要求configUSE_TICKLESS_IDLE被设置为
 * 非1的值时，portSUPPRESS_TICKS_AND_SLEEP()仍能被调用。
 */
#if ( configUSE_TICKLESS_IDLE != 0 )

    static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

/*
 * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 * will exit the Blocked state.
 */
/*将 xNextTaskUnblockTime 设置为下一个阻塞状态任务退出阻塞状态的时间*/
static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;

#if ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 )

/*
 * Helper function used to pad task names with spaces when printing out
 * human readable tables of task information.
 */
/*在打印人类可读的任务信息表格时，用于在任务名称后填充空格的辅助函数。*/
    static char * prvWriteNameToBuffer( char * pcBuffer,
                                        const char * pcTaskName ) PRIVILEGED_FUNCTION;

#endif

/*
 * Called after a Task_t structure has been allocated either statically or
 * dynamically to fill in the structure's members.
 */
/*在 Task_t（即TCB_t）结构体通过静态或动态方式分配后被调用，用于填充该结构体的成员。*/
static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
                                  const char * const pcName,
                                  const configSTACK_DEPTH_TYPE uxStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;

/*
 * Called after a new task has been created and initialised to place the task
 * under the control of the scheduler.
 */
/*在新任务被创建和初始化后调用，用于将任务置于调度器的控制之下。*/
static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;

/*
 * Create a task with static buffer for both TCB and stack. Returns a handle to
 * the task if it is created successfully. Otherwise, returns NULL.
 */
/*创建一个使用静态缓冲区存储TCB和栈的任务。若创建成功，返回任务句柄；否则返回NULL。*/
#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    static TCB_t * prvCreateStaticTask( TaskFunction_t pxTaskCode,
                                        const char * const pcName,
                                        const configSTACK_DEPTH_TYPE uxStackDepth,
                                        void * const pvParameters,
                                        UBaseType_t uxPriority,
                                        StackType_t * const puxStackBuffer,
                                        StaticTask_t * const pxTaskBuffer,
                                        TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
#endif /* #if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

/*
 * Create a restricted task with static buffer for both TCB and stack. Returns
 * a handle to the task if it is created successfully. Otherwise, returns NULL.
 */
/*创建一个使用静态缓冲区存储TCB和栈的受限任务。若创建成功，返回任务句柄；否则返回NULL。*/
#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    static TCB_t * prvCreateRestrictedStaticTask( const TaskParameters_t * const pxTaskDefinition,
                                                  TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
#endif /* #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */


/*
 * Create a restricted task with static buffer for task stack and allocated buffer
 * for TCB. Returns a handle to the task if it is created successfully. Otherwise,
 * returns NULL.
 */
#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    static TCB_t * prvCreateRestrictedTask( const TaskParameters_t * const pxTaskDefinition,
                                            TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
#endif /* #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */


/*
 * Create a task with allocated buffer for both TCB and stack. Returns a handle to
 * the task if it is created successfully. Otherwise, returns NULL.
 */
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    static TCB_t * prvCreateTask( TaskFunction_t pxTaskCode,
                                  const char * const pcName,
                                  const configSTACK_DEPTH_TYPE uxStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
#endif /* #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) */

/*
 * freertos_tasks_c_additions_init() should only be called if the user definable
 * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 * called by the function.
 */
/*
 * freertos_tasks_c_additions_init() 仅应在用户可定义的宏
 * FREERTOS_TASKS_C_ADDITIONS_INIT() 被定义时调用，因为该函数仅会调用这个宏。
 */
#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT

    static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;

#endif

#if ( configUSE_PASSIVE_IDLE_HOOK == 1 )
    extern void vApplicationPassiveIdleHook( void );
#endif /* #if ( configUSE_PASSIVE_IDLE_HOOK == 1 ) */

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

/*
 * Convert the snprintf return value to the number of characters
 * written. The following are the possible cases:
 *
 * 1. The buffer supplied to snprintf is large enough to hold the
 *    generated string. The return value in this case is the number
 *    of characters actually written, not counting the terminating
 *    null character.
 * 2. The buffer supplied to snprintf is NOT large enough to hold
 *    the generated string. The return value in this case is the
 *    number of characters that would have been written if the
 *    buffer had been sufficiently large, not counting the
 *    terminating null character.
 * 3. Encoding error. The return value in this case is a negative
 *    number.
 *
 * From 1 and 2 above ==> Only when the return value is non-negative
 * and less than the supplied buffer length, the string has been
 * completely written.
 */
    static size_t prvSnprintfReturnValueToCharsWritten( int iSnprintfReturnValue,
                                                        size_t n );

#endif /* #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )
    static void prvCheckForRunStateChange( void )
    {
        UBaseType_t uxPrevCriticalNesting;
        const TCB_t * pxThisTCB;

        /* This must only be called from within a task. */
        portASSERT_IF_IN_ISR();

        /* This function is always called with interrupts disabled
         * so this is safe. */
        pxThisTCB = pxCurrentTCBs[ portGET_CORE_ID() ];

        while( pxThisTCB->xTaskRunState == taskTASK_SCHEDULED_TO_YIELD )
        {
            /* We are only here if we just entered a critical section
            * or if we just suspended the scheduler, and another task
            * has requested that we yield.
            *
            * This is slightly complicated since we need to save and restore
            * the suspension and critical nesting counts, as well as release
            * and reacquire the correct locks. And then, do it all over again
            * if our state changed again during the reacquisition. */
            uxPrevCriticalNesting = portGET_CRITICAL_NESTING_COUNT();

            if( uxPrevCriticalNesting > 0U )
            {
                portSET_CRITICAL_NESTING_COUNT( 0U );
                portRELEASE_ISR_LOCK();
            }
            else
            {
                /* The scheduler is suspended. uxSchedulerSuspended is updated
                 * only when the task is not requested to yield. */
                mtCOVERAGE_TEST_MARKER();
            }

            portRELEASE_TASK_LOCK();
            portMEMORY_BARRIER();
            configASSERT( pxThisTCB->xTaskRunState == taskTASK_SCHEDULED_TO_YIELD );

            portENABLE_INTERRUPTS();

            /* Enabling interrupts should cause this core to immediately
             * service the pending interrupt and yield. If the run state is still
             * yielding here then that is a problem. */
            configASSERT( pxThisTCB->xTaskRunState != taskTASK_SCHEDULED_TO_YIELD );

            portDISABLE_INTERRUPTS();
            portGET_TASK_LOCK();
            portGET_ISR_LOCK();

            portSET_CRITICAL_NESTING_COUNT( uxPrevCriticalNesting );

            if( uxPrevCriticalNesting == 0U )
            {
                portRELEASE_ISR_LOCK();
            }
        }
    }
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */

/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )
    static void prvYieldForTask( const TCB_t * pxTCB )
    {
        BaseType_t xLowestPriorityToPreempt;
        BaseType_t xCurrentCoreTaskPriority;
        BaseType_t xLowestPriorityCore = ( BaseType_t ) -1;
        BaseType_t xCoreID;

        #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
            BaseType_t xYieldCount = 0;
        #endif /* #if ( configRUN_MULTIPLE_PRIORITIES == 0 ) */

        /* This must be called from a critical section. */
        configASSERT( portGET_CRITICAL_NESTING_COUNT() > 0U );

        #if ( configRUN_MULTIPLE_PRIORITIES == 0 )

            /* No task should yield for this one if it is a lower priority
             * than priority level of currently ready tasks. */
            if( pxTCB->uxPriority >= uxTopReadyPriority )
        #else
            /* Yield is not required for a task which is already running. */
            if( taskTASK_IS_RUNNING( pxTCB ) == pdFALSE )
        #endif
        {
            xLowestPriorityToPreempt = ( BaseType_t ) pxTCB->uxPriority;

            /* xLowestPriorityToPreempt will be decremented to -1 if the priority of pxTCB
             * is 0. This is ok as we will give system idle tasks a priority of -1 below. */
            --xLowestPriorityToPreempt;

            for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
            {
                xCurrentCoreTaskPriority = ( BaseType_t ) pxCurrentTCBs[ xCoreID ]->uxPriority;

                /* System idle tasks are being assigned a priority of tskIDLE_PRIORITY - 1 here. */
                if( ( pxCurrentTCBs[ xCoreID ]->uxTaskAttributes & taskATTRIBUTE_IS_IDLE ) != 0U )
                {
                    xCurrentCoreTaskPriority = ( BaseType_t ) ( xCurrentCoreTaskPriority - 1 );
                }

                if( ( taskTASK_IS_RUNNING( pxCurrentTCBs[ xCoreID ] ) != pdFALSE ) && ( xYieldPendings[ xCoreID ] == pdFALSE ) )
                {
                    #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
                        if( taskTASK_IS_RUNNING( pxTCB ) == pdFALSE )
                    #endif
                    {
                        if( xCurrentCoreTaskPriority <= xLowestPriorityToPreempt )
                        {
                            #if ( configUSE_CORE_AFFINITY == 1 )
                                if( ( pxTCB->uxCoreAffinityMask & ( ( UBaseType_t ) 1U << ( UBaseType_t ) xCoreID ) ) != 0U )
                            #endif
                            {
                                #if ( configUSE_TASK_PREEMPTION_DISABLE == 1 )
                                    if( pxCurrentTCBs[ xCoreID ]->xPreemptionDisable == pdFALSE )
                                #endif
                                {
                                    xLowestPriorityToPreempt = xCurrentCoreTaskPriority;
                                    xLowestPriorityCore = xCoreID;
                                }
                            }
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }

                    #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
                    {
                        /* Yield all currently running non-idle tasks with a priority lower than
                         * the task that needs to run. */
                        if( ( xCurrentCoreTaskPriority > ( ( BaseType_t ) tskIDLE_PRIORITY - 1 ) ) &&
                            ( xCurrentCoreTaskPriority < ( BaseType_t ) pxTCB->uxPriority ) )
                        {
                            prvYieldCore( xCoreID );
                            xYieldCount++;
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    #endif /* #if ( configRUN_MULTIPLE_PRIORITIES == 0 ) */
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
                if( ( xYieldCount == 0 ) && ( xLowestPriorityCore >= 0 ) )
            #else /* #if ( configRUN_MULTIPLE_PRIORITIES == 0 ) */
                if( xLowestPriorityCore >= 0 )
            #endif /* #if ( configRUN_MULTIPLE_PRIORITIES == 0 ) */
            {
                prvYieldCore( xLowestPriorityCore );
            }

            #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
                /* Verify that the calling core always yields to higher priority tasks. */
                if( ( ( pxCurrentTCBs[ portGET_CORE_ID() ]->uxTaskAttributes & taskATTRIBUTE_IS_IDLE ) == 0U ) &&
                    ( pxTCB->uxPriority > pxCurrentTCBs[ portGET_CORE_ID() ]->uxPriority ) )
                {
                    configASSERT( ( xYieldPendings[ portGET_CORE_ID() ] == pdTRUE ) ||
                                  ( taskTASK_IS_RUNNING( pxCurrentTCBs[ portGET_CORE_ID() ] ) == pdFALSE ) );
                }
            #endif
        }
    }
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/


#if ( configNUMBER_OF_CORES > 1 )
    static void prvSelectHighestPriorityTask( BaseType_t xCoreID )
    {
        UBaseType_t uxCurrentPriority = uxTopReadyPriority;
        BaseType_t xTaskScheduled = pdFALSE;
        BaseType_t xDecrementTopPriority = pdTRUE;
        TCB_t * pxTCB = NULL;

        #if ( configUSE_CORE_AFFINITY == 1 )
            const TCB_t * pxPreviousTCB = NULL;
        #endif
        #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
            BaseType_t xPriorityDropped = pdFALSE;
        #endif

        /* This function should be called when scheduler is running. */
        configASSERT( xSchedulerRunning == pdTRUE );

        /* A new task is created and a running task with the same priority yields
         * itself to run the new task. When a running task yields itself, it is still
         * in the ready list. This running task will be selected before the new task
         * since the new task is always added to the end of the ready list.
         * The other problem is that the running task still in the same position of
         * the ready list when it yields itself. It is possible that it will be selected
         * earlier then other tasks which waits longer than this task.
         *
         * To fix these problems, the running task should be put to the end of the
         * ready list before searching for the ready task in the ready list. */
        if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxCurrentTCBs[ xCoreID ]->uxPriority ] ),
                                     &pxCurrentTCBs[ xCoreID ]->xStateListItem ) == pdTRUE )
        {
            ( void ) uxListRemove( &pxCurrentTCBs[ xCoreID ]->xStateListItem );
            vListInsertEnd( &( pxReadyTasksLists[ pxCurrentTCBs[ xCoreID ]->uxPriority ] ),
                            &pxCurrentTCBs[ xCoreID ]->xStateListItem );
        }

        while( xTaskScheduled == pdFALSE )
        {
            #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
            {
                if( uxCurrentPriority < uxTopReadyPriority )
                {
                    /* We can't schedule any tasks, other than idle, that have a
                     * priority lower than the priority of a task currently running
                     * on another core. */
                    uxCurrentPriority = tskIDLE_PRIORITY;
                }
            }
            #endif

            if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxCurrentPriority ] ) ) == pdFALSE )
            {
                const List_t * const pxReadyList = &( pxReadyTasksLists[ uxCurrentPriority ] );
                const ListItem_t * pxEndMarker = listGET_END_MARKER( pxReadyList );
                ListItem_t * pxIterator;

                /* The ready task list for uxCurrentPriority is not empty, so uxTopReadyPriority
                 * must not be decremented any further. */
                xDecrementTopPriority = pdFALSE;

                for( pxIterator = listGET_HEAD_ENTRY( pxReadyList ); pxIterator != pxEndMarker; pxIterator = listGET_NEXT( pxIterator ) )
                {
                    /* MISRA Ref 11.5.3 [Void pointer assignment] */
                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                    /* coverity[misra_c_2012_rule_11_5_violation] */
                    pxTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxIterator );

                    #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
                    {
                        /* When falling back to the idle priority because only one priority
                         * level is allowed to run at a time, we should ONLY schedule the true
                         * idle tasks, not user tasks at the idle priority. */
                        if( uxCurrentPriority < uxTopReadyPriority )
                        {
                            if( ( pxTCB->uxTaskAttributes & taskATTRIBUTE_IS_IDLE ) == 0U )
                            {
                                continue;
                            }
                        }
                    }
                    #endif /* #if ( configRUN_MULTIPLE_PRIORITIES == 0 ) */

                    if( pxTCB->xTaskRunState == taskTASK_NOT_RUNNING )
                    {
                        #if ( configUSE_CORE_AFFINITY == 1 )
                            if( ( pxTCB->uxCoreAffinityMask & ( ( UBaseType_t ) 1U << ( UBaseType_t ) xCoreID ) ) != 0U )
                        #endif
                        {
                            /* If the task is not being executed by any core swap it in. */
                            pxCurrentTCBs[ xCoreID ]->xTaskRunState = taskTASK_NOT_RUNNING;
                            #if ( configUSE_CORE_AFFINITY == 1 )
                                pxPreviousTCB = pxCurrentTCBs[ xCoreID ];
                            #endif
                            pxTCB->xTaskRunState = xCoreID;
                            pxCurrentTCBs[ xCoreID ] = pxTCB;
                            xTaskScheduled = pdTRUE;
                        }
                    }
                    else if( pxTCB == pxCurrentTCBs[ xCoreID ] )
                    {
                        configASSERT( ( pxTCB->xTaskRunState == xCoreID ) || ( pxTCB->xTaskRunState == taskTASK_SCHEDULED_TO_YIELD ) );

                        #if ( configUSE_CORE_AFFINITY == 1 )
                            if( ( pxTCB->uxCoreAffinityMask & ( ( UBaseType_t ) 1U << ( UBaseType_t ) xCoreID ) ) != 0U )
                        #endif
                        {
                            /* The task is already running on this core, mark it as scheduled. */
                            pxTCB->xTaskRunState = xCoreID;
                            xTaskScheduled = pdTRUE;
                        }
                    }
                    else
                    {
                        /* This task is running on the core other than xCoreID. */
                        mtCOVERAGE_TEST_MARKER();
                    }

                    if( xTaskScheduled != pdFALSE )
                    {
                        /* A task has been selected to run on this core. */
                        break;
                    }
                }
            }
            else
            {
                if( xDecrementTopPriority != pdFALSE )
                {
                    uxTopReadyPriority--;
                    #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
                    {
                        xPriorityDropped = pdTRUE;
                    }
                    #endif
                }
            }

            /* There are configNUMBER_OF_CORES Idle tasks created when scheduler started.
             * The scheduler should be able to select a task to run when uxCurrentPriority
             * is tskIDLE_PRIORITY. uxCurrentPriority is never decreased to value blow
             * tskIDLE_PRIORITY. */
            if( uxCurrentPriority > tskIDLE_PRIORITY )
            {
                uxCurrentPriority--;
            }
            else
            {
                /* This function is called when idle task is not created. Break the
                 * loop to prevent uxCurrentPriority overrun. */
                break;
            }
        }

        #if ( configRUN_MULTIPLE_PRIORITIES == 0 )
        {
            if( xTaskScheduled == pdTRUE )
            {
                if( xPriorityDropped != pdFALSE )
                {
                    /* There may be several ready tasks that were being prevented from running because there was
                     * a higher priority task running. Now that the last of the higher priority tasks is no longer
                     * running, make sure all the other idle tasks yield. */
                    BaseType_t x;

                    for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configNUMBER_OF_CORES; x++ )
                    {
                        if( ( pxCurrentTCBs[ x ]->uxTaskAttributes & taskATTRIBUTE_IS_IDLE ) != 0U )
                        {
                            prvYieldCore( x );
                        }
                    }
                }
            }
        }
        #endif /* #if ( configRUN_MULTIPLE_PRIORITIES == 0 ) */

        #if ( configUSE_CORE_AFFINITY == 1 )
        {
            if( xTaskScheduled == pdTRUE )
            {
                if( ( pxPreviousTCB != NULL ) && ( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxPreviousTCB->uxPriority ] ), &( pxPreviousTCB->xStateListItem ) ) != pdFALSE ) )
                {
                    /* A ready task was just evicted from this core. See if it can be
                     * scheduled on any other core. */
                    UBaseType_t uxCoreMap = pxPreviousTCB->uxCoreAffinityMask;
                    BaseType_t xLowestPriority = ( BaseType_t ) pxPreviousTCB->uxPriority;
                    BaseType_t xLowestPriorityCore = -1;
                    BaseType_t x;

                    if( ( pxPreviousTCB->uxTaskAttributes & taskATTRIBUTE_IS_IDLE ) != 0U )
                    {
                        xLowestPriority = xLowestPriority - 1;
                    }

                    if( ( uxCoreMap & ( ( UBaseType_t ) 1U << ( UBaseType_t ) xCoreID ) ) != 0U )
                    {
                        /* pxPreviousTCB was removed from this core and this core is not excluded
                         * from it's core affinity mask.
                         *
                         * pxPreviousTCB is preempted by the new higher priority task
                         * pxCurrentTCBs[ xCoreID ]. When searching a new core for pxPreviousTCB,
                         * we do not need to look at the cores on which pxCurrentTCBs[ xCoreID ]
                         * is allowed to run. The reason is - when more than one cores are
                         * eligible for an incoming task, we preempt the core with the minimum
                         * priority task. Because this core (i.e. xCoreID) was preempted for
                         * pxCurrentTCBs[ xCoreID ], this means that all the others cores
                         * where pxCurrentTCBs[ xCoreID ] can run, are running tasks with priority
                         * no lower than pxPreviousTCB's priority. Therefore, the only cores where
                         * which can be preempted for pxPreviousTCB are the ones where
                         * pxCurrentTCBs[ xCoreID ] is not allowed to run (and obviously,
                         * pxPreviousTCB is allowed to run).
                         *
                         * This is an optimization which reduces the number of cores needed to be
                         * searched for pxPreviousTCB to run. */
                        uxCoreMap &= ~( pxCurrentTCBs[ xCoreID ]->uxCoreAffinityMask );
                    }
                    else
                    {
                        /* pxPreviousTCB's core affinity mask is changed and it is no longer
                         * allowed to run on this core. Searching all the cores in pxPreviousTCB's
                         * new core affinity mask to find a core on which it can run. */
                    }

                    uxCoreMap &= ( ( 1U << configNUMBER_OF_CORES ) - 1U );

                    for( x = ( ( BaseType_t ) configNUMBER_OF_CORES - 1 ); x >= ( BaseType_t ) 0; x-- )
                    {
                        UBaseType_t uxCore = ( UBaseType_t ) x;
                        BaseType_t xTaskPriority;

                        if( ( uxCoreMap & ( ( UBaseType_t ) 1U << uxCore ) ) != 0U )
                        {
                            xTaskPriority = ( BaseType_t ) pxCurrentTCBs[ uxCore ]->uxPriority;

                            if( ( pxCurrentTCBs[ uxCore ]->uxTaskAttributes & taskATTRIBUTE_IS_IDLE ) != 0U )
                            {
                                xTaskPriority = xTaskPriority - ( BaseType_t ) 1;
                            }

                            uxCoreMap &= ~( ( UBaseType_t ) 1U << uxCore );

                            if( ( xTaskPriority < xLowestPriority ) &&
                                ( taskTASK_IS_RUNNING( pxCurrentTCBs[ uxCore ] ) != pdFALSE ) &&
                                ( xYieldPendings[ uxCore ] == pdFALSE ) )
                            {
                                #if ( configUSE_TASK_PREEMPTION_DISABLE == 1 )
                                    if( pxCurrentTCBs[ uxCore ]->xPreemptionDisable == pdFALSE )
                                #endif
                                {
                                    xLowestPriority = xTaskPriority;
                                    xLowestPriorityCore = ( BaseType_t ) uxCore;
                                }
                            }
                        }
                    }

                    if( xLowestPriorityCore >= 0 )
                    {
                        prvYieldCore( xLowestPriorityCore );
                    }
                }
            }
        }
        #endif /* #if ( configUSE_CORE_AFFINITY == 1 ) */
    }

#endif /* ( configNUMBER_OF_CORES > 1 ) */

/*-----------------------------------------------------------*/

// 当支持静态内存分配时，定义该函数
#if ( configSUPPORT_STATIC_ALLOCATION == 1 )

    // 静态函数：创建静态任务（使用用户预分配的内存），返回新任务的TCB指针
    static TCB_t * prvCreateStaticTask( TaskFunction_t pxTaskCode,  // 任务入口函数指针
                                        const char * const pcName,  // 任务名称
                                        const configSTACK_DEPTH_TYPE uxStackDepth,  // 栈深度（变量数量）
                                        void * const pvParameters,  // 传递给任务的参数
                                        UBaseType_t uxPriority,     // 任务优先级
                                        StackType_t * const puxStackBuffer,  // 用户预分配的静态栈缓冲区
                                        StaticTask_t * const pxTaskBuffer,   // 用户预分配的静态TCB缓冲区
                                        TaskHandle_t * const pxCreatedTask ) // 输出参数：任务句柄
    {
        TCB_t * pxNewTCB;  // 指向新任务TCB的指针

        // 断言断：确保栈缓冲区和TCB缓冲区不为NULL（静态分配必须由用户提供内存）
        configASSERT( puxStackBuffer != NULL );
        configASSERT( pxTaskBuffer != NULL );

        #if ( configASSERT_DEFINED == 1 )  // 若启用断言功能
        {
            /* 合理性检查：验证StaticTask_t类型的大小是否与实际TCB_t类型一致
             * （防止用户定义的StaticTask_t与内核内部TCB_t不匹配导致内存错误） */
            volatile size_t xSize = sizeof( StaticTask_t );
            configASSERT( xSize == sizeof( TCB_t ) );
            ( void ) xSize;  // 当断言未启用时，避免“变量未使用”警告
        }
        #endif /* configASSERT_DEFINED */

        // 若栈缓冲区和TCB缓冲区均有效
        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
        {
            /* 任务的TCB和栈内存由用户传入，直接使用这些内存 */
            /* MISRA规则11.3.1相关注释（关于内存对齐访问） */
            /* 更多细节参见：https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-113 */
            /* coverity工具的MISRA规则11.3违规标记 */
            pxNewTCB = ( TCB_t * ) pxTaskBuffer;  // 将用户提供的StaticTask_t指针转为TCB_t指针
            ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );  // 初始化TCB为全0
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;  // 绑定用户提供的栈缓冲区

            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )  // 内核同时支持静态和动态分配
            {
                /* 标记任务为“静态分配”（栈和TCB均由用户提供），
                 * 便于后续删除任务时正确处理内存（静态分配的内存无需内核释放） */
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
            
            // 调用通用初始化函数，填充TCB的其他成员（如任务函数、优先级、栈顶地址等）
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, 
                                 uxPriority, pxCreatedTask, pxNewTCB, NULL );
        }
        else
        {
            pxNewTCB = NULL;  // 内存缓冲区无效，返回NULL表示创建失败
        }

        return pxNewTCB;  // 返回新任务的TCB指针（失败则为NULL）
    }
/*-----------------------------------------------------------*/
#endif /* configSUPPORT_STATIC_ALLOCATION == 1 */

    TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
                                    const char * const pcName,
                                    const configSTACK_DEPTH_TYPE uxStackDepth,
                                    void * const pvParameters,
                                    UBaseType_t uxPriority,
                                    StackType_t * const puxStackBuffer,
                                    StaticTask_t * const pxTaskBuffer )
    {
        TaskHandle_t xReturn = NULL;
        TCB_t * pxNewTCB;

        traceENTER_xTaskCreateStatic( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );

        pxNewTCB = prvCreateStaticTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer, &xReturn );

        if( pxNewTCB != NULL )
        {
            #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = configTASK_DEFAULT_CORE_AFFINITY;
            }
            #endif

            prvAddNewTaskToReadyList( pxNewTCB );/*在新任务被创建和初始化后调用，用于将任务置于调度器的控制之下。*/
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_xTaskCreateStatic( xReturn );

        return xReturn;
    }
/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

    #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
        TaskHandle_t xTaskCreateStaticAffinitySet( TaskFunction_t pxTaskCode,
                                                   const char * const pcName,
                                                   const configSTACK_DEPTH_TYPE uxStackDepth,
                                                   void * const pvParameters,
                                                   UBaseType_t uxPriority,
                                                   StackType_t * const puxStackBuffer,
                                                   StaticTask_t * const pxTaskBuffer,
                                                   UBaseType_t uxCoreAffinityMask )
        {
            TaskHandle_t xReturn = NULL;
            TCB_t * pxNewTCB;

            traceENTER_xTaskCreateStaticAffinitySet( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer, uxCoreAffinityMask );

            pxNewTCB = prvCreateStaticTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer, &xReturn );

            if( pxNewTCB != NULL )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = uxCoreAffinityMask;

                prvAddNewTaskToReadyList( pxNewTCB );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            traceRETURN_xTaskCreateStaticAffinitySet( xReturn );

            return xReturn;
        }
    #endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) ) */

#endif /* SUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    static TCB_t * prvCreateRestrictedStaticTask( const TaskParameters_t * const pxTaskDefinition,
                                                  TaskHandle_t * const pxCreatedTask )
    {
        TCB_t * pxNewTCB;

        configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );

        if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
        {
            /* Allocate space for the TCB.  Where the memory comes from depends
             * on the implementation of the port malloc function and whether or
             * not static allocation is being used. */
            pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
            ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );

            /* Store the stack location in the TCB. */
            pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
            {
                /* Tasks can be created statically or dynamically, so note this
                 * task was created statically in case the task is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
                                  pxTaskDefinition->pcName,
                                  pxTaskDefinition->usStackDepth,
                                  pxTaskDefinition->pvParameters,
                                  pxTaskDefinition->uxPriority,
                                  pxCreatedTask, pxNewTCB,
                                  pxTaskDefinition->xRegions );
        }
        else
        {
            pxNewTCB = NULL;
        }

        return pxNewTCB;
    }
/*-----------------------------------------------------------*/

    BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
                                            TaskHandle_t * pxCreatedTask )
    {
        TCB_t * pxNewTCB;
        BaseType_t xReturn;

        traceENTER_xTaskCreateRestrictedStatic( pxTaskDefinition, pxCreatedTask );

        configASSERT( pxTaskDefinition != NULL );

        pxNewTCB = prvCreateRestrictedStaticTask( pxTaskDefinition, pxCreatedTask );

        if( pxNewTCB != NULL )
        {
            #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = configTASK_DEFAULT_CORE_AFFINITY;
            }
            #endif

            prvAddNewTaskToReadyList( pxNewTCB );
            xReturn = pdPASS;
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        traceRETURN_xTaskCreateRestrictedStatic( xReturn );

        return xReturn;
    }
/*-----------------------------------------------------------*/

    #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
        BaseType_t xTaskCreateRestrictedStaticAffinitySet( const TaskParameters_t * const pxTaskDefinition,
                                                           UBaseType_t uxCoreAffinityMask,
                                                           TaskHandle_t * pxCreatedTask )
        {
            TCB_t * pxNewTCB;
            BaseType_t xReturn;

            traceENTER_xTaskCreateRestrictedStaticAffinitySet( pxTaskDefinition, uxCoreAffinityMask, pxCreatedTask );

            configASSERT( pxTaskDefinition != NULL );

            pxNewTCB = prvCreateRestrictedStaticTask( pxTaskDefinition, pxCreatedTask );

            if( pxNewTCB != NULL )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = uxCoreAffinityMask;

                prvAddNewTaskToReadyList( pxNewTCB );
                xReturn = pdPASS;
            }
            else
            {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
            }

            traceRETURN_xTaskCreateRestrictedStaticAffinitySet( xReturn );

            return xReturn;
        }
    #endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) ) */

#endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    static TCB_t * prvCreateRestrictedTask( const TaskParameters_t * const pxTaskDefinition,
                                            TaskHandle_t * const pxCreatedTask )
    {
        TCB_t * pxNewTCB;

        configASSERT( pxTaskDefinition->puxStackBuffer );

        if( pxTaskDefinition->puxStackBuffer != NULL )
        {
            /* MISRA Ref 11.5.1 [Malloc memory assignment] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity[misra_c_2012_rule_11_5_violation] */
            pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

            if( pxNewTCB != NULL )
            {
                ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );

                /* Store the stack location in the TCB. */
                pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;

                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
                {
                    /* Tasks can be created statically or dynamically, so note
                     * this task had a statically allocated stack in case it is
                     * later deleted.  The TCB was allocated dynamically. */
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
                }
                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

                prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
                                      pxTaskDefinition->pcName,
                                      pxTaskDefinition->usStackDepth,
                                      pxTaskDefinition->pvParameters,
                                      pxTaskDefinition->uxPriority,
                                      pxCreatedTask, pxNewTCB,
                                      pxTaskDefinition->xRegions );
            }
        }
        else
        {
            pxNewTCB = NULL;
        }

        return pxNewTCB;
    }
/*-----------------------------------------------------------*/

    BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
                                      TaskHandle_t * pxCreatedTask )
    {
        TCB_t * pxNewTCB;
        BaseType_t xReturn;

        traceENTER_xTaskCreateRestricted( pxTaskDefinition, pxCreatedTask );

        pxNewTCB = prvCreateRestrictedTask( pxTaskDefinition, pxCreatedTask );

        if( pxNewTCB != NULL )
        {
            #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = configTASK_DEFAULT_CORE_AFFINITY;
            }
            #endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) ) */

            prvAddNewTaskToReadyList( pxNewTCB );

            xReturn = pdPASS;
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        traceRETURN_xTaskCreateRestricted( xReturn );

        return xReturn;
    }
/*-----------------------------------------------------------*/

    #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
        BaseType_t xTaskCreateRestrictedAffinitySet( const TaskParameters_t * const pxTaskDefinition,
                                                     UBaseType_t uxCoreAffinityMask,
                                                     TaskHandle_t * pxCreatedTask )
        {
            TCB_t * pxNewTCB;
            BaseType_t xReturn;

            traceENTER_xTaskCreateRestrictedAffinitySet( pxTaskDefinition, uxCoreAffinityMask, pxCreatedTask );

            pxNewTCB = prvCreateRestrictedTask( pxTaskDefinition, pxCreatedTask );

            if( pxNewTCB != NULL )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = uxCoreAffinityMask;

                prvAddNewTaskToReadyList( pxNewTCB );

                xReturn = pdPASS;
            }
            else
            {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
            }

            traceRETURN_xTaskCreateRestrictedAffinitySet( xReturn );

            return xReturn;
        }
    #endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) ) */


#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    // 静态函数：创建任务的内部实现，返回新任务的TCB（任务控制块）指针
    static TCB_t * prvCreateTask( TaskFunction_t pxTaskCode,
                                  const char * const pcName,
                                  const configSTACK_DEPTH_TYPE uxStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask )
    {
        TCB_t * pxNewTCB;  // 指向新任务控制块的指针

        /* 如果栈是向上增长的，则先分配TCB再分配栈，避免栈溢出覆盖TCB；
         * 如果栈是向下增长的，则先分配栈再分配TCB，同样避免栈溢出问题 */
        #if ( portSTACK_GROWTH > 0 )  // 栈向上增长（从低地址到高地址）
        {
            /* 为TCB分配内存。内存来源取决于端口malloc函数的实现以及是否使用静态分配 */
            /* MISRA规则11.5.1相关注释（关于malloc内存分配） */
            /* 更多细节参见：https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity工具的MISRA规则11.5违规标记 */
            pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

            if( pxNewTCB != NULL )  // TCB分配成功
            {
                // 将TCB所有字节初始化为0
                ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );

                /* 为任务栈分配内存。栈的基地址存储在TCB中，以便后续删除任务时释放 */
                /* MISRA规则11.5.1相关注释 */
                pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocStack( 
                    ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) )  // 计算栈的总字节数
                );

                if( pxNewTCB->pxStack == NULL )  // 栈分配失败
                {
                    // 释放已分配的TCB内存
                    vPortFree( pxNewTCB );
                    pxNewTCB = NULL;  // 标记创建失败
                }
            }
        }
        #else /* portSTACK_GROWTH <= 0，栈向下增长（从高地址到低地址） */
        {
            StackType_t * pxStack;  // 指向栈内存的指针

            /* 先为任务栈分配内存 */
            pxStack = pvPortMallocStack( 
                ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) )
            );

            if( pxStack != NULL )  // 栈分配成功
            {
                /* 再为TCB分配内存 */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

                if( pxNewTCB != NULL )  // TCB分配成功
                {
                    // 初始化TCB为全0
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
                    // 将栈地址存储到TCB中
                    pxNewTCB->pxStack = pxStack;
                }
                else  // TCB分配失败
                {
                    // 释放已分配的栈内存
                    vPortFreeStack( pxStack );
                }
            }
            else  // 栈分配失败
            {
                pxNewTCB = NULL;  // 标记创建失败
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )  // TCB和栈均分配成功
        {
            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
            {
                /* 任务可静态或动态创建，此处标记为动态分配（栈和TCB均动态分配），
                 * 以便后续删除任务时正确释放内存 */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            // 初始化新任务的其他属性（如任务函数、名称、优先级等）
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, 
                                 uxPriority, pxCreatedTask, pxNewTCB, NULL );
        }

        return pxNewTCB;  // 返回新任务的TCB指针（失败则返回NULL）
    }
/*-----------------------------------------------------------*/
#endif /* configSUPPORT_DYNAMIC_ALLOCATION == 1 */

    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
                            const char * const pcName,
                            const configSTACK_DEPTH_TYPE uxStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
        TCB_t * pxNewTCB;
        BaseType_t xReturn;

        traceENTER_xTaskCreate( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );

        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );

        if( pxNewTCB != NULL )
        {
            #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = configTASK_DEFAULT_CORE_AFFINITY;
            }
            #endif

            prvAddNewTaskToReadyList( pxNewTCB );
            xReturn = pdPASS;
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        traceRETURN_xTaskCreate( xReturn );

        return xReturn;
    }
/*-----------------------------------------------------------*/

    #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
        BaseType_t xTaskCreateAffinitySet( TaskFunction_t pxTaskCode,
                                           const char * const pcName,
                                           const configSTACK_DEPTH_TYPE uxStackDepth,
                                           void * const pvParameters,
                                           UBaseType_t uxPriority,
                                           UBaseType_t uxCoreAffinityMask,
                                           TaskHandle_t * const pxCreatedTask )
        {
            TCB_t * pxNewTCB;
            BaseType_t xReturn;

            traceENTER_xTaskCreateAffinitySet( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, uxCoreAffinityMask, pxCreatedTask );

            pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );

            if( pxNewTCB != NULL )
            {
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = uxCoreAffinityMask;

                prvAddNewTaskToReadyList( pxNewTCB );
                xReturn = pdPASS;
            }
            else
            {
                xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
            }

            traceRETURN_xTaskCreateAffinitySet( xReturn );

            return xReturn;
        }
    #endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) ) */

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

// 静态函数：初始化新任务的核心属性（TCB配置、栈初始化、任务状态设置等）
static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
                                  const char * const pcName,
                                  const configSTACK_DEPTH_TYPE uxStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    StackType_t * pxTopOfStack;  // 指向任务栈顶的指针
    UBaseType_t x;               // 循环计数器


    // ===================== 模块1：MPU特权模式判断（仅启用MPU封装时生效） =====================
    #if ( portUSING_MPU_WRAPPERS == 1 )  // MPU（内存保护单元）功能已启用
        /* 任务是否应在特权模式（系统模式）下运行？ */
        BaseType_t xRunPrivileged;

        // 检查优先级参数中是否包含“特权模式标记位”（portPRIVILEGE_BIT）
        if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
        {
            xRunPrivileged = pdTRUE;  // 任务运行在特权模式（可访问所有内存/外设）
        }
        else
        {
            xRunPrivileged = pdFALSE; // 任务运行在非特权模式（受MPU权限限制）
        }
        // 清除优先级中的“特权标记位”，还原真实优先级数值
        uxPriority &= ~portPRIVILEGE_BIT;
    #endif /* portUSING_MPU_WRAPPERS == 1 */


    // ===================== 模块2：栈内存初始化（调试辅助） =====================
    /* 仅在需要时使用memset，避免不必要的依赖 */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    {
        // 用已知值（tskSTACK_FILL_BYTE）填充栈内存，便于调试时观察栈使用情况（如栈溢出检测）
        ( void ) memset( pxNewTCB->pxStack, 
                        ( int ) tskSTACK_FILL_BYTE, 
                        ( size_t ) uxStackDepth * sizeof( StackType_t )  // 栈总字节数
                      );
    }
    #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 */


    // ===================== 模块3：计算栈顶地址（适配不同栈增长方向） =====================
    /* 栈顶地址的计算依赖于栈的增长方向（从高地址到低地址，或反之）
     * portSTACK_GROWTH 用于控制地址计算的正负方向，适配不同CPU架构 */
    #if ( portSTACK_GROWTH < 0 )  // 栈向下增长（如ARM Cortex-M系列，从高地址→低地址）
    {
        // 栈向下增长时，栈顶是栈数组的“最后一个元素地址”（初始状态栈为空，栈顶即栈的最高地址）
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
        // 栈顶地址对齐处理（确保符合CPU要求的内存对齐规则，如4字节/8字节对齐）
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) 
                                          & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

        // 断言：验证栈顶地址对齐是否正确（若失败则触发调试断言）
        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0U ) );

        #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
        {
            // 记录栈的最高地址（用于调试，辅助定位栈溢出问题）
            pxNewTCB->pxEndOfStack = pxTopOfStack;
        }
        #endif /* configRECORD_STACK_HIGH_ADDRESS */
    }
    #else /* portSTACK_GROWTH >= 0 ：栈向上增长（如x86，从低地址→高地址） */
    {
        // 栈向上增长时，栈顶初始为栈数组的“第一个元素地址”
        pxTopOfStack = pxNewTCB->pxStack;
        // 地址对齐处理
        pxTopOfStack = ( StackType_t * ) ( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) + portBYTE_ALIGNMENT_MASK ) 
                                          & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

        // 断言：验证对齐正确性
        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0U ) );

        // 记录栈的最低地址（栈向上增长时，栈底为栈的边界，用于栈溢出检测）
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 );
    }
    #endif /* portSTACK_GROWTH */


    // ===================== 模块4：任务名称写入TCB =====================
    if( pcName != NULL )  // 任务名称不为空
    {
        // 循环将任务名称复制到TCB的pcTaskName数组中（最大长度由configMAX_TASK_NAME_LEN限制）
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];

            // 若名称长度小于最大限制，遇到字符串结束符（'\0'）则提前退出循环
            if( pcName[ x ] == ( char ) 0x00 )
            {
                break;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无实际逻辑）
            }
        }

        // 确保任务名称始终以'\0'结尾（即使名称长度等于最大限制，避免字符串越界）
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }


    // ===================== 模块5：任务优先级配置 =====================
    // 断言：确保任务优先级不超过系统最大支持优先级（避免数组越界）
    configASSERT( uxPriority < configMAX_PRIORITIES );

    // 若优先级超出最大限制，强制设为“最大优先级-1”（容错处理）
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    // 将最终优先级写入TCB
    pxNewTCB->uxPriority = uxPriority;
    #if ( configUSE_MUTEXES == 1 )  // 启用互斥锁功能
    {
        // 记录“基础优先级”（互斥锁优先级继承机制需用到，避免优先级反转）
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */


    // ===================== 模块6：TCB链表项初始化（任务调度核心） =====================
    // 初始化“任务状态链表项”（用于加入就绪/阻塞/挂起等状态链表）
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    // 初始化“任务事件链表项”（用于等待事件时加入事件链表，如信号量/队列）
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );

    /* 为链表项设置“所属TCB”的回指指针
     * 作用：从通用链表项（ListItem_t）反向找到对应的TCB，便于调度器操作任务 */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

    /* 事件链表始终按优先级排序：
     * 链表项“值”设为（最大优先级 - 任务优先级），确保高优先级任务的链表项值更小，
     * 排序时排在链表前端，实现“高优先级任务优先被唤醒”的逻辑 */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), 
                            ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );


    // ===================== 模块7：MPU内存区域配置（仅启用MPU时生效） =====================
    #if ( portUSING_MPU_WRAPPERS == 1 )
    {
        // 为任务配置MPU内存区域（如代码段、数据段、栈的权限），参数包含内存区域定义、栈地址等
        vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), 
                                  xRegions, 
                                  pxNewTCB->pxStack, 
                                  uxStackDepth );
    }
    #else
    {
        // 未启用MPU时，避免编译器“未引用参数”警告
        ( void ) xRegions;
    }
    #endif


    // ===================== 模块8：C运行时TLS初始化（线程局部存储） =====================
    #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )  // 启用线程局部存储（TLS）
    {
        // 为任务分配并初始化TLS块（存储线程私有数据，如线程专属的全局变量）
        configINIT_TLS_BLOCK( pxNewTCB->xTLSBlock, pxTopOfStack );
    }
    #endif


    // ===================== 模块9：栈初始化（模拟任务被中断的上下文） =====================
    /* 初始化栈内容，使其看起来像“任务已运行但被调度器中断”的状态
     * 栈中会预置任务入口函数地址、参数、寄存器值等，确保任务首次运行时能正确执行 */
    #if ( portUSING_MPU_WRAPPERS == 1 )  // 启用MPU
    {
        #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )  // 启用栈溢出检测
        {
            // 按栈增长方向，传入栈底/栈顶地址，初始化栈（含MPU配置）
            #if ( portSTACK_GROWTH < 0 )
            {
                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                                                               pxNewTCB->pxStack,  // 栈底（向下增长时栈的最低地址）
                                                               pxTaskCode, 
                                                               pvParameters, 
                                                               xRunPrivileged, 
                                                               &( pxNewTCB->xMPUSettings ) );
            }
            #else
            {
                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                                                               pxNewTCB->pxEndOfStack,  // 栈底（向上增长时栈的最低地址）
                                                               pxTaskCode, 
                                                               pvParameters, 
                                                               xRunPrivileged, 
                                                               &( pxNewTCB->xMPUSettings ) );
            }
            #endif
        }
        #else  // 未启用栈溢出检测
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                                                           pxTaskCode, 
                                                           pvParameters, 
                                                           xRunPrivileged, 
                                                           &( pxNewTCB->xMPUSettings ) );
        }
        #endif
    }
    #else  // 未启用MPU
    {
        #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )  // 启用栈溢出检测
        {
            // 按栈增长方向初始化栈（不含MPU配置）
            #if ( portSTACK_GROWTH < 0 )
            {
                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                                                               pxNewTCB->pxStack, 
                                                               pxTaskCode, 
                                                               pvParameters );
            }
            #else
            {
                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                                                               pxNewTCB->pxEndOfStack, 
                                                               pxTaskCode, 
                                                               pvParameters );
            }
            #endif
        }
        #else  // 未启用栈溢出检测
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, 
                                                           pxTaskCode, 
                                                           pvParameters );
        }
        #endif
    }
    #endif /* portUSING_MPU_WRAPPERS */


    // ===================== 模块10：多核系统任务状态初始化 =====================
    #if ( configNUMBER_OF_CORES > 1 )  // 多核处理器环境
    {
        // 初始状态设为“未运行”（taskTASK_NOT_RUNNING），等待调度器分配核心
        pxNewTCB->xTaskRunState = taskTASK_NOT_RUNNING;

        // 检查当前任务是否为空闲任务（prvIdleTask/prvPassiveIdleTask）
        if( ( ( TaskFunction_t ) pxTaskCode == ( TaskFunction_t ) prvIdleTask ) || 
            ( ( TaskFunction_t ) pxTaskCode == ( TaskFunction_t ) prvPassiveIdleTask ) )
        {
            // 标记任务为“空闲任务”（用于多核调度器识别空闲核心）
            pxNewTCB->uxTaskAttributes |= taskATTRIBUTE_IS_IDLE;
        }
    }
    #endif /* configNUMBER_OF_CORES > 1 */


    // ===================== 模块11：返回任务句柄 =====================
    if( pxCreatedTask != NULL )  // 任务句柄指针不为空（需要返回句柄）
    {
        /* 将TCB指针包装为“任务句柄”（TaskHandle_t）返回给用户
         * 用户可通过句柄操作任务（如修改优先级、删除任务等） */
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
// 翻译：静态函数，无返回值，参数为指向新任务控制块(TCB)的指针pxNewTCB
// 解析：该函数是FreeRTOS内部函数，负责将新创建的任务添加到就绪链表，并处理相关初始化逻辑
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    // 翻译：/* 确保在更新任务链表时，中断不会访问这些链表 */
    // 进入临界区（保护任务链表操作不被中断或其他任务干扰）
    taskENTER_CRITICAL();
    {
        // 增加系统当前任务总数（uxCurrentNumberOfTasks是全局变量）
        uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );

        // 如果当前没有正在运行的任务（pxCurrentTCB为NULL）
        if( pxCurrentTCB == NULL )
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            // 翻译：/* 没有其他任务，或所有其他任务都处于挂起状态 - 将此任务设为当前任务 */
            pxCurrentTCB = pxNewTCB;

            // 如果这是系统创建的第一个任务
            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                // 翻译：/* 这是第一个被创建的任务，因此执行必要的初步初始化。
                //        如果此调用失败，我们无法恢复，但会报告失败 */
                /* 第一个任务创建：执行任务链表初始化 */
                prvInitialiseTaskLists(); // 初始化FreeRTOS所有任务链表（就绪、挂起、阻塞等）
            }
            else
            {
                mtCOVERAGE_TEST_MARKER(); // 测试覆盖率标记，实际无功能
            }
        }
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            // 翻译：/* 如果调度器尚未运行，且此任务是目前创建的优先级最高的任务，则将其设为当前任务 */
            
            // 调度器未启动时（xSchedulerRunning是标记调度器状态的全局变量）
            if( xSchedulerRunning == pdFALSE )
            {
                /* 调度器未启动：若新任务优先级 ≥ 当前任务，更新当前任务 */
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
                {
                    pxCurrentTCB = pxNewTCB; // 新任务优先级更高或相同，设为当前任务
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        // 任务编号自增（用于标识任务创建顺序）
        uxTaskNumber++;

        // 如果启用了跟踪功能（configUSE_TRACE_FACILITY宏定义为1）
        #if ( configUSE_TRACE_FACILITY == 1 )
        {
            /* Add a counter into the TCB for tracing only. */
            // 翻译：/* 仅为跟踪目的，向TCB添加一个计数器 */
            /* 为 TCB 添加跟踪用的任务编号 */
            pxNewTCB->uxTCBNumber = uxTaskNumber; // 将当前任务编号存入新任务的TCB
        }
        #endif /* configUSE_TRACE_FACILITY */

        // 跟踪宏：记录任务创建事件（用于调试和跟踪工具）
        traceTASK_CREATE( pxNewTCB );

        // 将新任务添加到就绪链表（内部函数，根据任务优先级插入对应就绪链表）
        prvAddTaskToReadyList( pxNewTCB );

        // 移植层宏：执行与硬件相关的TCB初始化（如栈指针调整等平台相关操作）
        portSETUP_TCB( pxNewTCB );
    }
    // 退出临界区（恢复中断）
    taskEXIT_CRITICAL();

    // 如果调度器已经在运行
    if( xSchedulerRunning != pdFALSE )
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        // 翻译：/* 如果创建的任务优先级高于当前任务，则应立即运行 */
        /* 若新任务优先级高于当前任务，触发任务切换 */
        taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
        // 上述宏的作用：如果新任务优先级更高，触发任务切换（在多核系统中会选择合适的核）
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}

#else /* #if ( configNUMBER_OF_CORES == 1 ) */

    static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
    {
        /* Ensure interrupts don't access the task lists while the lists are being
         * updated. */
        taskENTER_CRITICAL();
        {
            uxCurrentNumberOfTasks++;

            if( xSchedulerRunning == pdFALSE )
            {
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
                {
                    /* This is the first task to be created so do the preliminary
                     * initialisation required.  We will not recover if this call
                     * fails, but we will report the failure. */
                    prvInitialiseTaskLists();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                /* All the cores start with idle tasks before the SMP scheduler
                 * is running. Idle tasks are assigned to cores when they are
                 * created in prvCreateIdleTasks(). */
            }

            uxTaskNumber++;

            #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
            #endif /* configUSE_TRACE_FACILITY */
            traceTASK_CREATE( pxNewTCB );

            prvAddTaskToReadyList( pxNewTCB );

            portSETUP_TCB( pxNewTCB );

            if( xSchedulerRunning != pdFALSE )
            {
                /* If the created task is of a higher priority than another
                 * currently running task and preemption is on then it should
                 * run now. */
                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    }

#endif /* #if ( configNUMBER_OF_CORES == 1 ) */
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

    static size_t prvSnprintfReturnValueToCharsWritten( int iSnprintfReturnValue,
                                                        size_t n )
    {
        size_t uxCharsWritten;

        if( iSnprintfReturnValue < 0 )
        {
            /* Encoding error - Return 0 to indicate that nothing
             * was written to the buffer. */
            uxCharsWritten = 0;
        }
        else if( iSnprintfReturnValue >= ( int ) n )
        {
            /* This is the case when the supplied buffer is not
             * large to hold the generated string. Return the
             * number of characters actually written without
             * counting the terminating NULL character. */
            uxCharsWritten = n - 1U;
        }
        else
        {
            /* Complete string was written to the buffer. */
            uxCharsWritten = ( size_t ) iSnprintfReturnValue;
        }

        return uxCharsWritten;
    }

#endif /* #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/


// 仅当启用任务删除功能时，定义 vTaskDelete 函数
#if ( INCLUDE_vTaskDelete == 1 )

    // 函数：删除指定任务（从内核管理链表中移除，并触发后续内存清理）
    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
        TCB_t * pxTCB;  // 指向待删除任务的TCB指针
        BaseType_t xDeleteTCBInIdleTask = pdFALSE;  // 标记是否需在空闲任务中清理TCB
        BaseType_t xTaskIsRunningOrYielding;  // 标记任务是否正在运行或即将触发上下文切换

        traceENTER_vTaskDelete( xTaskToDelete );  // 跟踪函数入口（调试/性能分析用）

        // ===================== 模块1：进入临界区，保护任务链表操作 =====================
        taskENTER_CRITICAL();
        {
            /* 若传入NULL，则删除当前调用该函数的任务（自删除）；否则通过句柄获取目标TCB */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );

            /* 步骤1：将任务从“就绪链表”或“延迟链表”（如等待超时的任务链表）中移除 */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
            {
                // 若该优先级链表中已无其他任务，重置该优先级的“就绪标记”（优化调度效率）
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无实际逻辑）
            }

            /* 步骤2：检查任务是否还在“事件链表”中（如等待信号量、队列的任务链表） */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
            {
                // 从事件链表中移除任务
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* 步骤3：递增任务编号（uxTaskNumber）
             * 作用：让内核感知调试器需要重新生成任务链表，确保调试信息实时性
             * 需在portPRE_TASK_DELETE_HOOK前执行，因Windows移植中该钩子不会返回 */
            uxTaskNumber++;

            /* 步骤4：读取任务运行状态（使用临时变量确保符合MISRA C 2012 Rule 13.5）
             * MISRA要求：volatile变量的读取需有明确序列点，避免编译器优化导致的读取异常 */
            xTaskIsRunningOrYielding = taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB );

            /* 步骤5：处理“正在运行/即将切换”的任务（核心逻辑）
             * 若任务正在运行或即将触发yield，无法立即删除（需先切换到其他任务），需交由空闲任务后续处理 */
            if( ( xSchedulerRunning != pdFALSE ) && ( xTaskIsRunningOrYielding != pdFALSE ) )
            {
                /* 正在运行的任务或待切换的任务被删除时，需先放入“终止链表”（xTasksWaitingTermination）
                 * 空闲任务会遍历该链表，释放任务的TCB和栈内存（内核动态分配的部分） */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );

                // 递增“待清理删除任务计数器”，告知空闲任务有任务需清理
                ++uxDeletedTasksWaitingCleanUp;

                traceTASK_DELETE( pxTCB );  // 跟踪任务删除事件

                xDeleteTCBInIdleTask = pdTRUE;  // 标记需在空闲任务中清理TCB

                /* 执行“预删除钩子”（portPRE_TASK_DELETE_HOOK）
                 * 主要用于Windows模拟器：执行Windows特定清理操作，之后无法主动yield，需标记上下文切换请求 */
                #if ( configNUMBER_OF_CORES == 1 )  // 单核系统
                    portPRE_TASK_DELETE_HOOK( pxTCB, &( xYieldPendings[ 0 ] ) );
                #else  // 多核系统
                    portPRE_TASK_DELETE_HOOK( pxTCB, &( xYieldPendings[ pxTCB->xTaskRunState ] ) );
                #endif

                /* 多核系统（SMP）特殊处理：
                 * 被删除的任务可能在其他核心运行，需先“驱逐”该任务（触发其核心的上下文切换）
                 * 确保任务不会重新进入就绪/事件链表，避免删除操作失效 */
                #if ( configNUMBER_OF_CORES > 1 )
                {
                    if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )  // 任务正在其他核心运行
                    {
                        if( pxTCB->xTaskRunState == ( BaseType_t ) portGET_CORE_ID() )
                        {
                            // 任务在当前核心运行，断言调度器未挂起，触发API内上下文切换
                            configASSERT( uxSchedulerSuspended == 0 );
                            taskYIELD_WITHIN_API();
                        }
                        else
                        {
                            // 任务在其他核心运行，触发目标核心的上下文切换
                            prvYieldCore( pxTCB->xTaskRunState );
                        }
                    }
                }
                #endif /* configNUMBER_OF_CORES > 1 */
            }
            else
            {
                // 任务未在运行且无需切换：直接递减系统当前任务总数
                --uxCurrentNumberOfTasks;
                traceTASK_DELETE( pxTCB );  // 跟踪任务删除事件

                /* 重置“下一个任务解阻塞时间”
                 * 防止该时间指向已删除的任务，导致调度器计算超时错误 */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();  // 退出临界区，恢复任务调度


        // ===================== 模块2：非空闲任务清理路径（任务未在运行时） =====================
        /* 若无需在空闲任务中清理（即任务未运行/非自删除），直接调用prvDeleteTCB释放内存
         * 若为自删除，prvDeleteTCB由空闲任务的prvCheckTasksWaitingTermination调用 */
        if( xDeleteTCBInIdleTask != pdTRUE )
        {
            prvDeleteTCB( pxTCB );  // 释放任务的TCB和栈内存（仅动态分配的部分）
        }


        // ===================== 模块3：单核系统自删除后的强制调度 =====================
        /* 单核系统中，若删除的是“当前运行的任务”，需强制触发上下文切换
         * 因为当前任务已被标记为删除，需立即切换到其他就绪任务 */
        #if ( configNUMBER_OF_CORES == 1 )
        {
            if( xSchedulerRunning != pdFALSE )
            {
                if( pxTCB == pxCurrentTCB )  // 确认删除的是当前任务
                {
                    configASSERT( uxSchedulerSuspended == 0 );  // 断言调度器未挂起
                    taskYIELD_WITHIN_API();  // 在API内触发上下文切换
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        #endif /* configNUMBER_OF_CORES == 1 */

        traceRETURN_vTaskDelete();  // 跟踪函数返回（调试/性能分析用）
    }

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

// 仅当启用 xTaskDelayUntil 功能时，定义该函数
#if ( INCLUDE_xTaskDelayUntil == 1 )

    // 函数：将任务阻塞到指定的绝对时间（确保周期性执行）
    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,  // 指向“上一次唤醒时间”的指针
                                const TickType_t xTimeIncrement )       // 任务周期（单位：系统节拍数）
    {
        TickType_t xTimeToWake;                // 本次目标唤醒时间（绝对时间）
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;  // xShouldDelay：标记是否需要阻塞任务

        traceENTER_xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );  // 跟踪函数入口

        // 断言：确保参数有效（pxPreviousWakeTime 不为NULL，周期 xTimeIncrement 大于0）
        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );

        // 挂起调度器（禁止任务切换，确保时间计算的原子性）
        vTaskSuspendAll();
        {
            /* 优化：当前代码块内，系统节拍计数（xTickCount）不会变化（因调度器已挂起） */
            const TickType_t xConstTickCount = xTickCount;  // 存储当前系统节拍数

            configASSERT( uxSchedulerSuspended == 1U );  // 断言调度器已挂起

            /* 计算本次目标唤醒时间 = 上一次唤醒时间 + 周期（确保固定周期） */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

            // ===================== 核心逻辑：判断是否需要阻塞任务 =====================
            if( xConstTickCount < *pxPreviousWakeTime )
            {
                /* 场景1：系统节拍计数（xTickCount）已溢出（如从最大值回到0）
                 * 仅当“目标唤醒时间也溢出”且“目标唤醒时间 > 当前节拍数”时，才需要阻塞
                 * （此时相当于两者均未溢出，目标时间在未来） */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
                {
                    xShouldDelay = pdTRUE;  // 需要阻塞
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记
                }
            }
            else
            {
                /* 场景2：系统节拍计数未溢出
                 * 若“目标唤醒时间溢出”（因加上周期后超过最大值）或“目标唤醒时间 > 当前节拍数”，则需要阻塞 */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
                {
                    xShouldDelay = pdTRUE;  // 需要阻塞
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* 更新“上一次唤醒时间”为本次目标唤醒时间（供下次调用使用） */
            *pxPreviousWakeTime = xTimeToWake;

            // 若需要阻塞，将当前任务加入延迟链表
            if( xShouldDelay != pdFALSE )
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );  // 跟踪延迟事件

                /* prvAddCurrentTaskToDelayedList 需要“阻塞时长”而非“目标唤醒时间”，
                 * 因此用目标时间减去当前节拍数（xTimeToWake - xConstTickCount） */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        // 恢复调度器，返回值表示恢复时是否已触发上下文切换
        xAlreadyYielded = xTaskResumeAll();

        /* 若调度器恢复时未触发切换，手动触发一次（确保任务切换到其他就绪任务） */
        if( xAlreadyYielded == pdFALSE )
        {
            taskYIELD_WITHIN_API();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_xTaskDelayUntil( xShouldDelay );  // 跟踪函数返回

        return xShouldDelay;  // 返回是否实际阻塞了任务
    }

#endif /* INCLUDE_xTaskDelayUntil */
/*-----------------------------------------------------------*/


// 仅当启用 vTaskDelay 功能时，定义该函数
#if ( INCLUDE_vTaskDelay == 1 )

    // 函数：将当前任务阻塞指定的节拍数（相对延迟）
    void vTaskDelay( const TickType_t xTicksToDelay )
    {
        BaseType_t xAlreadyYielded = pdFALSE;  // 标记调度器恢复时是否已触发上下文切换

        traceENTER_vTaskDelay( xTicksToDelay );  // 跟踪函数入口（调试/性能分析用）

        /* 若延迟节拍数为0，仅触发一次任务调度（不阻塞任务） */
        if( xTicksToDelay > ( TickType_t ) 0U )
        {
            // ===================== 模块1：挂起调度器，保护延迟链表操作 =====================
            vTaskSuspendAll();  // 挂起调度器（禁止其他任务修改任务链表，避免并发冲突）
            {
                // 断言：确认调度器已成功挂起（uxSchedulerSuspended 应为1）
                configASSERT( uxSchedulerSuspended == 1U );

                traceTASK_DELAY();  // 跟踪“任务延迟”事件

                /* 关键说明：
                 * 调度器挂起期间，从事件链表中移除的任务，需等到调度器恢复后才会被加入就绪链表/移出阻塞链表；
                 * 当前任务是正在执行的任务，不可能处于任何事件链表中（无需处理事件链表移除）。 */
                // 将当前任务加入“延迟链表”（xDelayedTaskList1 或 xDelayedTaskList2），阻塞 xTicksToDelay 个节拍
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
            }
            // 恢复调度器，返回值 xAlreadyYielded 表示恢复时是否已触发上下文切换
            xAlreadyYielded = xTaskResumeAll();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无实际逻辑）
        }

        // ===================== 模块2：确保任务调度（若未自动触发） =====================
        /* 若调度器恢复时未触发上下文切换（xAlreadyYielded == pdFALSE），
         * 需手动触发调度——因为当前任务可能已被加入延迟链表，需切换到其他就绪任务 */
        if( xAlreadyYielded == pdFALSE )
        {
            taskYIELD_WITHIN_API();  // 在API内部触发上下文切换
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskDelay();  // 跟踪函数返回（调试/性能分析用）
    }

#endif /* INCLUDE_vTaskDelay */
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

    eTaskState eTaskGetState( TaskHandle_t xTask )
    {
        eTaskState eReturn;
        List_t const * pxStateList;
        List_t const * pxEventList;
        List_t const * pxDelayedList;
        List_t const * pxOverflowedDelayedList;
        const TCB_t * const pxTCB = xTask;

        traceENTER_eTaskGetState( xTask );

        configASSERT( pxTCB );

        #if ( configNUMBER_OF_CORES == 1 )
            if( pxTCB == pxCurrentTCB )
            {
                /* The task calling this function is querying its own state. */
                eReturn = eRunning;
            }
            else
        #endif
        {
            taskENTER_CRITICAL();
            {
                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
                pxEventList = listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) );
                // 获取延迟任务链表
                pxDelayedList = pxDelayedTaskList;
                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
            }
            taskEXIT_CRITICAL();

            // 检查任务是否在 pending ready 链表中
            if( pxEventList == &xPendingReadyList )
            {
                /* The task has been placed on the pending ready list, so its
                 * state is eReady regardless of what list the task's state list
                 * item is currently placed on. */
                eReturn = eReady;
            }
            else if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
            {
                /* The task being queried is referenced from one of the Blocked
                 * lists. */
                eReturn = eBlocked;
            }

            #if ( INCLUDE_vTaskSuspend == 1 )
                else if( pxStateList == &xSuspendedTaskList )
                {
                    /* The task being queried is referenced from the suspended
                     * list.  Is it genuinely suspended or is it blocked
                     * indefinitely? */
                    /* 被查询的任务在挂起链表中，需要判断是真的挂起还是无限期阻塞 */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
                    {
                        #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                        {
                            BaseType_t x;

                            /* The task does not appear on the event list item of
                             * and of the RTOS objects, but could still be in the
                             * blocked state if it is waiting on its notification
                             * rather than waiting on an object.  If not, is
                             * suspended. */
                            /* 任务不在任何RTOS对象的事件链表中，但如果它在等待通知
                             * 而不是等待对象，仍可能处于阻塞状态，否则就是挂起状态 */
                            eReturn = eSuspended;

                            for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                            {
                                if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
                                {
                                    eReturn = eBlocked;
                                    break;
                                }
                            }
                        }
                        #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                        {
                            eReturn = eSuspended;
                        }
                        #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                    }
                    else
                    {
                        eReturn = eBlocked;
                    }
                }
            #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */

            #if ( INCLUDE_vTaskDelete == 1 )
                // 检查任务是否在等待终止链表中或不在任何链表中
                else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
                {
                    /* The task being queried is referenced from the deleted
                     * tasks list, or it is not referenced from any lists at
                     * all. */
                    eReturn = eDeleted;
                }
            #endif

            else
            {
                #if ( configNUMBER_OF_CORES == 1 )
                {
                    /* If the task is not in any other state, it must be in the
                     * Ready (including pending ready) state. */
                    eReturn = eReady;
                }
                #else /* #if ( configNUMBER_OF_CORES == 1 ) */
                {
                    if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
                    {
                        /* Is it actively running on a core? */
                        eReturn = eRunning;
                    }
                    else
                    {
                        /* If the task is not in any other state, it must be in the
                         * Ready (including pending ready) state. */
                        eReturn = eReady;
                    }
                }
                #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
            }
        }

        traceRETURN_eTaskGetState( eReturn );

        return eReturn;
    }

#endif /* INCLUDE_eTaskGetState */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        traceENTER_uxTaskPriorityGet( xTask );

        taskENTER_CRITICAL();
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
            uxReturn = pxTCB->uxPriority;
        }
        taskEXIT_CRITICAL();

        traceRETURN_uxTaskPriorityGet( uxReturn );

        return uxReturn;
    }

#endif /* INCLUDE_uxTaskPriorityGet */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;
        UBaseType_t uxSavedInterruptStatus;

        traceENTER_uxTaskPriorityGetFromISR( xTask );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
         * failure if a FreeRTOS API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        /*中断优先级断言检查，确保：
                *调用该函数的中断优先级不高于 configMAX_SYSCALL_INTERRUPT_PRIORITY
                *防止在不允许调用 FreeRTOS API 的高优先级中断中使用该函数
                *具体实现依赖硬件平台（如 Cortex-M 系列的 NVIC 优先级配置）*/
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        /*中断版本的进入临界区宏，功能是：
            *禁用低于或等于 configMAX_SYSCALL_INTERRUPT_PRIORITY 的中断
            *返回当前中断状态，用于后续恢复
            *与普通 taskENTER_CRITICAL 不同，它专为中断上下文设计，不会导致中断嵌套问题*/
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
            uxReturn = pxTCB->uxPriority;
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_uxTaskPriorityGetFromISR( uxReturn );

        return uxReturn;
    }

#endif /* INCLUDE_uxTaskPriorityGet */
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_uxTaskPriorityGet == 1 ) && ( configUSE_MUTEXES == 1 ) )
    //当任务因 “优先级继承”（互斥锁场景）临时提升优先级时，仍能获取到任务的原始优先级。
    UBaseType_t uxTaskBasePriorityGet( const TaskHandle_t xTask )
    {
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        traceENTER_uxTaskBasePriorityGet( xTask );

        taskENTER_CRITICAL();
        {
            /* If null is passed in here then it is the base priority of the task
             * that called uxTaskBasePriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
            uxReturn = pxTCB->uxBasePriority;
        }
        taskEXIT_CRITICAL();

        traceRETURN_uxTaskBasePriorityGet( uxReturn );

        return uxReturn;
    }

#endif /* #if ( ( INCLUDE_uxTaskPriorityGet == 1 ) && ( configUSE_MUTEXES == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_uxTaskPriorityGet == 1 ) && ( configUSE_MUTEXES == 1 ) )

    UBaseType_t uxTaskBasePriorityGetFromISR( const TaskHandle_t xTask )
    {
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;
        UBaseType_t uxSavedInterruptStatus;

        traceENTER_uxTaskBasePriorityGetFromISR( xTask );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
         * failure if a FreeRTOS API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
        {
            /* If null is passed in here then it is the base priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
            uxReturn = pxTCB->uxBasePriority;
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_uxTaskBasePriorityGetFromISR( uxReturn );

        return uxReturn;
    }

#endif /* #if ( ( INCLUDE_uxTaskPriorityGet == 1 ) && ( configUSE_MUTEXES == 1 ) ) */
/*-----------------------------------------------------------*/

// 仅当启用任务优先级设置功能时，定义该函数
#if ( INCLUDE_vTaskPrioritySet == 1 )

    // 函数：修改指定任务的优先级
    void vTaskPrioritySet( TaskHandle_t xTask,          // 待修改优先级的任务句柄（NULL 表示当前任务）
                           UBaseType_t uxNewPriority )   // 新的任务优先级
    {
        TCB_t * pxTCB;                                  // 指向目标任务的 TCB 指针
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;  // 当前基础优先级、修改前的优先级
        BaseType_t xYieldRequired = pdFALSE;            // 标记是否需要触发上下文切换

        #if ( configNUMBER_OF_CORES > 1 )  // 多核系统额外变量：标记是否需为目标任务触发切换
            BaseType_t xYieldForTask = pdFALSE;
        #endif

        traceENTER_vTaskPrioritySet( xTask, uxNewPriority );  // 跟踪函数入口（调试/性能分析用）

        // 断言：确保新优先级不超过系统最大优先级（configMAX_PRIORITIES）
        configASSERT( uxNewPriority < configMAX_PRIORITIES );

        /* 确保新优先级合法：若超过最大优先级，强制设为最大优先级-1 */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无实际逻辑）
        }

        // ===================== 模块1：进入临界区，保护任务链表操作 =====================
        taskENTER_CRITICAL();
        {
            /* 若传入 NULL，修改当前调用函数的任务优先级；否则通过句柄获取目标 TCB */
            pxTCB = prvGetTCBFromHandle( xTask );

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );  // 跟踪优先级修改事件

            // 读取任务当前的“基础优先级”（区分是否启用互斥锁优先级继承）
            #if ( configUSE_MUTEXES == 1 )  // 启用互斥锁时，基础优先级存储在 uxBasePriority
            {
                uxCurrentBasePriority = pxTCB->uxBasePriority;
            }
            #else  // 未启用互斥锁时，优先级直接存储在 uxPriority
            {
                uxCurrentBasePriority = pxTCB->uxPriority;
            }
            #endif

            /* 仅当新优先级与当前基础优先级不同时，才执行后续修改逻辑 */
            if( uxCurrentBasePriority != uxNewPriority )
            {
                // -------------------- 子模块1.1：判断是否需要触发上下文切换 --------------------
                if( uxNewPriority > uxCurrentBasePriority )
                {
                    // 场景1：提升任务优先级
                    #if ( configNUMBER_OF_CORES == 1 )  // 单核系统
                    {
                        if( pxTCB != pxCurrentTCB )  // 若修改的是“非当前运行任务”
                        {
                            /* 检查新优先级是否高于当前运行任务的优先级：
                             * 若是，则需触发切换（让高优先级任务立即执行） */
                            if( uxNewPriority > pxCurrentTCB->uxPriority )
                            {
                                xYieldRequired = pdTRUE;
                            }
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            /* 若修改的是“当前运行任务”：
                             * 当前任务已是最高优先级可运行任务，无需触发切换 */
                        }
                    }
                    #else  // 多核系统：提升任务优先级时，标记需为该任务触发切换
                    {
                        xYieldForTask = pdTRUE;
                    }
                    #endif
                }
                // 场景2：降低任务优先级，且任务当前正在运行
                else if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
                {
                    /* 降低运行中任务的优先级后，可能有更高优先级任务就绪，需触发切换 */
                    #if ( configUSE_TASK_PREEMPTION_DISABLE == 1 )  // 若启用抢占禁用
                        if( pxTCB->xPreemptionDisable == pdFALSE )  // 仅当任务未禁用抢占时，才需切换
                    #endif
                    {
                        xYieldRequired = pdTRUE;
                    }
                }
                else
                {
                    /* 场景3：降低“非运行任务”的优先级：
                     * 当前运行任务优先级已高于修改后的优先级，无需触发切换 */
                }

                // -------------------- 子模块1.2：更新任务优先级相关成员 --------------------
                /* 记录修改前的优先级：用于后续从旧就绪链表中移除任务 */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;

                #if ( configUSE_MUTEXES == 1 )  // 启用互斥锁（支持优先级继承）
                {
                    /* 仅在以下两种情况更新当前优先级（uxPriority）：
                     * 1. 任务未使用优先级继承（基础优先级 == 当前优先级）；
                     * 2. 新优先级高于当前继承的优先级（避免覆盖更高的继承优先级）。 */
                    if( ( pxTCB->uxBasePriority == pxTCB->uxPriority ) || ( uxNewPriority > pxTCB->uxPriority ) )
                    {
                        pxTCB->uxPriority = uxNewPriority;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* 基础优先级（uxBasePriority）无论是否继承，均更新为新优先级 */
                    pxTCB->uxBasePriority = uxNewPriority;
                }
                #else  // 未启用互斥锁：直接更新优先级
                {
                    pxTCB->uxPriority = uxNewPriority;
                }
                #endif

                // -------------------- 子模块1.3：更新事件链表项的优先级标记 --------------------
                /* 事件链表项（xEventListItem）的值用于排序：仅当该值未被占用时（如未用于超时时间），
                 * 才更新为“最大优先级 - 新优先级”（确保高优先级任务在事件链表中靠前）。 */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) );
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                // -------------------- 子模块1.4：调整任务在就绪链表中的位置 --------------------
                /* 若任务当前在“旧优先级的就绪链表”中，需将其移到“新优先级的就绪链表” */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
                {
                    // 1. 从旧就绪链表中移除任务
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
                    {
                        /* 若旧链表中已无其他任务，重置该优先级的“就绪标记”（优化调度效率） */
                        portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    // 2. 将任务加入新优先级的就绪链表
                    prvAddTaskToReadyList( pxTCB );
                }
                else
                {
                    // 任务不在就绪链表中（如阻塞/挂起），无需调整链表；多核系统需重置切换标记
                    #if ( configNUMBER_OF_CORES == 1 )
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                    #else
                    {
                        xYieldForTask = pdFALSE;  // 任务未就绪，无需为其触发切换
                    }
                    #endif
                }

                // -------------------- 子模块1.5：触发上下文切换（按需） --------------------
                if( xYieldRequired != pdFALSE )
                {
                    /* 降低运行任务优先级后，触发该任务所在核心的切换 */
                    taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxTCB );
                }
                else
                {
                    #if ( configNUMBER_OF_CORES > 1 )
                        if( xYieldForTask != pdFALSE )
                        {
                            /* 提升任务优先级后，触发任意核心的切换（让高优先级任务抢占） */
                            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
                        }
                        else
                    #endif
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                /* 避免编译器警告：当未使用端口优化的任务选择时，uxPriorityUsedOnEntry 可能被标记为“未使用” */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();  // 退出临界区，恢复任务调度

        traceRETURN_vTaskPrioritySet();  // 跟踪函数返回（调试/性能分析用）
    }

#endif /* INCLUDE_vTaskPrioritySet */
/*-----------------------------------------------------------*/

#if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
    void vTaskCoreAffinitySet( const TaskHandle_t xTask,
                               UBaseType_t uxCoreAffinityMask )
    {
        TCB_t * pxTCB;
        BaseType_t xCoreID;
        UBaseType_t uxPrevCoreAffinityMask;

        #if ( configUSE_PREEMPTION == 1 )
            UBaseType_t uxPrevNotAllowedCores;
        #endif

        traceENTER_vTaskCoreAffinitySet( xTask, uxCoreAffinityMask );

        taskENTER_CRITICAL();
        {
            pxTCB = prvGetTCBFromHandle( xTask );

            uxPrevCoreAffinityMask = pxTCB->uxCoreAffinityMask;
            pxTCB->uxCoreAffinityMask = uxCoreAffinityMask;

            if( xSchedulerRunning != pdFALSE )
            {
                if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
                {
                    xCoreID = ( BaseType_t ) pxTCB->xTaskRunState;

                    /* If the task can no longer run on the core it was running,
                     * request the core to yield. */
                    if( ( uxCoreAffinityMask & ( ( UBaseType_t ) 1U << ( UBaseType_t ) xCoreID ) ) == 0U )
                    {
                        prvYieldCore( xCoreID );
                    }
                }
                else
                {
                    #if ( configUSE_PREEMPTION == 1 )
                    {
                        /* Calculate the cores on which this task was not allowed to
                         * run previously. */
                        uxPrevNotAllowedCores = ( ~uxPrevCoreAffinityMask ) & ( ( 1U << configNUMBER_OF_CORES ) - 1U );

                        /* Does the new core mask enables this task to run on any of the
                         * previously not allowed cores? If yes, check if this task can be
                         * scheduled on any of those cores. */
                        if( ( uxPrevNotAllowedCores & uxCoreAffinityMask ) != 0U )
                        {
                            prvYieldForTask( pxTCB );
                        }
                    }
                    #else /* #if( configUSE_PREEMPTION == 1 ) */
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                    #endif /* #if( configUSE_PREEMPTION == 1 ) */
                }
            }
        }
        taskEXIT_CRITICAL();

        traceRETURN_vTaskCoreAffinitySet();
    }
#endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) )
    UBaseType_t vTaskCoreAffinityGet( ConstTaskHandle_t xTask )
    {
        const TCB_t * pxTCB;
        UBaseType_t uxCoreAffinityMask;

        traceENTER_vTaskCoreAffinityGet( xTask );

        taskENTER_CRITICAL();
        {
            pxTCB = prvGetTCBFromHandle( xTask );
            uxCoreAffinityMask = pxTCB->uxCoreAffinityMask;
        }
        taskEXIT_CRITICAL();

        traceRETURN_vTaskCoreAffinityGet( uxCoreAffinityMask );

        return uxCoreAffinityMask;
    }
#endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_CORE_AFFINITY == 1 ) ) */

/*-----------------------------------------------------------*/

#if ( configUSE_TASK_PREEMPTION_DISABLE == 1 )

    void vTaskPreemptionDisable( const TaskHandle_t xTask )
    {
        TCB_t * pxTCB;

        traceENTER_vTaskPreemptionDisable( xTask );

        taskENTER_CRITICAL();
        {
            pxTCB = prvGetTCBFromHandle( xTask );

            pxTCB->xPreemptionDisable = pdTRUE;
        }
        taskEXIT_CRITICAL();

        traceRETURN_vTaskPreemptionDisable();
    }

#endif /* #if ( configUSE_TASK_PREEMPTION_DISABLE == 1 ) */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_PREEMPTION_DISABLE == 1 )

    void vTaskPreemptionEnable( const TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        BaseType_t xCoreID;

        traceENTER_vTaskPreemptionEnable( xTask );

        taskENTER_CRITICAL();
        {
            pxTCB = prvGetTCBFromHandle( xTask );

            pxTCB->xPreemptionDisable = pdFALSE;

            if( xSchedulerRunning != pdFALSE )
            {
                if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
                {
                    xCoreID = ( BaseType_t ) pxTCB->xTaskRunState;
                    prvYieldCore( xCoreID );
                }
            }
        }
        taskEXIT_CRITICAL();

        traceRETURN_vTaskPreemptionEnable();
    }

#endif /* #if ( configUSE_TASK_PREEMPTION_DISABLE == 1 ) */
/*-----------------------------------------------------------*/

// 仅当启用任务挂起功能时，才编译该函数（通过FreeRTOSConfig.h配置）
#if ( INCLUDE_vTaskSuspend == 1 )

    // 函数：挂起指定任务（参数为任务句柄，传NULL则挂起当前任务）
    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
        TCB_t * pxTCB;  // 指向目标任务控制块（TCB）的指针

        traceENTER_vTaskSuspend( xTaskToSuspend );  // 调试跟踪：函数入口

        // 进入临界区（禁止任务切换，确保操作原子性）
        taskENTER_CRITICAL();
        {
            /* 若传入的任务句柄为NULL，说明要挂起当前正在运行的任务；
             * 否则通过句柄获取目标任务的TCB */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );

            traceTASK_SUSPEND( pxTCB );  // 调试跟踪：记录任务挂起事件

            /* 核心步骤1：将任务从当前所在的状态链表（就绪链表或延迟链表）中移除
             * 任务的xStateListItem用于挂载到状态链表，标识其就绪/阻塞状态 */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
            {
                // 若移除后链表为空，重置该优先级的就绪标记（优化调度效率）
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无实际逻辑）
            }

            /* 核心步骤2：检查任务是否还在某个事件链表中（如等待队列、信号量的链表）
             * listLIST_ITEM_CONTAINER用于判断链表项是否属于某个链表 */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
            {
                // 从事件链表中移除任务的事件链表项（xEventListItem）
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记
            }

            // 核心步骤3：将任务加入全局挂起链表（xSuspendedTaskList）
            // vListInsertEnd：将链表项插入链表末尾
            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );

            // 如果启用了任务通知功能（configUSE_TASK_NOTIFICATIONS == 1）
            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;  // 循环计数器

                // 遍历任务的所有通知状态（最多configTASK_NOTIFICATION_ARRAY_ENTRIES个）
                for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                {
                    // 若任务正在等待第x个通知，将状态改为“不等待”
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
                    {
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
                    }
                }
            }
            #endif /* configUSE_TASK_NOTIFICATIONS == 1 */

            // 多核系统（核心数>1）的特殊处理
            #if ( configNUMBER_OF_CORES > 1 )
            {
                // 若调度器正在运行
                if( xSchedulerRunning != pdFALSE )
                {
                    // 重置“下一个任务解阻塞时间”（被挂起的任务可能原本在延迟链表中）
                    prvResetNextTaskUnblockTime();

                    // 若被挂起的任务正在某个核心上运行
                    if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
                    {
                        // 若任务在当前核心运行，触发当前核心的任务切换
                        if( pxTCB->xTaskRunState == ( BaseType_t ) portGET_CORE_ID() )
                        {
                            configASSERT( uxSchedulerSuspended == 0 );  // 断言调度器未挂起
                            vTaskYieldWithinAPI();  // 触发当前核心的任务切换
                        }
                        // 若任务在其他核心运行，触发对应核心的任务切换
                        else
                        {
                            prvYieldCore( pxTCB->xTaskRunState );  // 通知其他核心切换任务
                        }
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记
                }
            }
            #endif /* configNUMBER_OF_CORES > 1 */
        }
        taskEXIT_CRITICAL();  // 退出临界区（恢复任务切换）

        // 单核系统（核心数==1）的特殊处理
        #if ( configNUMBER_OF_CORES == 1 )
        {
            UBaseType_t uxCurrentListLength;  // 挂起链表的长度

            // 若调度器正在运行
            if( xSchedulerRunning != pdFALSE )
            {
                // 重置“下一个任务解阻塞时间”（被挂起的任务可能原本在延迟链表中）
                taskENTER_CRITICAL();
                {
                    prvResetNextTaskUnblockTime();
                }
                taskEXIT_CRITICAL();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记
            }

            // 若被挂起的任务是当前正在运行的任务
            if( pxTCB == pxCurrentTCB )
            {
                if( xSchedulerRunning != pdFALSE )
                {
                    // 当前任务被挂起，强制触发任务切换（让出CPU）
                    configASSERT( uxSchedulerSuspended == 0 );  // 断言调度器未挂起
                    portYIELD_WITHIN_API();  // 触发任务切换
                }
                else
                {
                    /* 调度器未运行时，需要调整当前任务指针（pxCurrentTCB）：
                     * 先获取挂起链表的当前长度 */
                    uxCurrentListLength = listCURRENT_LIST_LENGTH( &xSuspendedTaskList );

                    // 若挂起链表长度等于总任务数，说明所有任务都被挂起
                    if( uxCurrentListLength == uxCurrentNumberOfTasks )
                    {
                        // 将当前任务指针设为NULL（后续创建新任务时会重新赋值）
                        pxCurrentTCB = NULL;
                    }
                    else
                    {
                        // 手动切换上下文，更新当前任务指针
                        vTaskSwitchContext();
                    }
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记
            }
        }
        #endif /* configNUMBER_OF_CORES == 1 */

        traceRETURN_vTaskSuspend();  // 调试跟踪：函数返回
    }

#endif /* INCLUDE_vTaskSuspend */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
        BaseType_t xReturn = pdFALSE;
        const TCB_t * const pxTCB = xTask;

        /* Accesses xPendingReadyList so must be called from a critical
         * section. */

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
        {
            /* Has the task already been resumed from within an ISR? */
            //xPendingReadyList 管理 “待就绪” 状态的任务 （如在中断中被唤醒的任务）
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because it is blocked with no timeout? */
                //判断任务的 “事件链表项”（xEventListItem）是否不属于任何事件链表
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
                {
                    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                    {
                        BaseType_t x;

                        /* The task does not appear on the event list item of
                         * and of the RTOS objects, but could still be in the
                         * blocked state if it is waiting on its notification
                         * rather than waiting on an object.  If not, is
                         * suspended. */
                        xReturn = pdTRUE;

                        for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                        {
                            if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
                            {
                                xReturn = pdFALSE;
                                break;
                            }
                        }
                    }
                    #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                    {
                        xReturn = pdTRUE;
                    }
                    #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }

#endif /* INCLUDE_vTaskSuspend */
/*-----------------------------------------------------------*/

// 仅当启用任务挂起功能时，才编译该恢复函数（与挂vTaskSuspend`配套）
#if ( INCLUDE_vTaskSuspend == 1 )

    // 函数：恢复被挂起的任务（参数为要恢复的任务句柄）
    void vTaskResume( TaskHandle_t xTaskToResume )
    {
        // 将传入的任务句柄转换为TCB指针（常量指针，防止意外修改）
        TCB_t * const pxTCB = xTaskToResume;

        traceENTER_vTaskResume( xTaskToResume );  // 调试跟踪：函数入口

        /* 恢复当前调用任务本身是没有意义的（当前任务不可能处于挂起态） */
        configASSERT( xTaskToResume );  // 断言：任务句柄不能为NULL

        // 单核系统（核心数==1）的判断逻辑
        #if ( configNUMBER_OF_CORES == 1 )

            /* 传入的参数不能为NULL，且不能是当前正在执行的任务（当前任务无法挂起自己） */
            if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
        #else  // 多核系统（核心数>1）的判断逻辑

            /* 传入的参数不能为NULL（当前任务无法恢复自己己）。
             * 虽然也不可能能恢复正在其他核心运行的任务，但此处全安全检查，
             * 因此进入临界区后再判断任务是否真的处于挂起态 */
            if( pxTCB != NULL )
        #endif
        {
            // 进入临界区，确保任务状态修改的原子性
            taskENTER_CRITICAL();
            {
                // 检查任务是否真的处于挂起态（通过判断是否在挂起链表中）
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
                {
                    traceTASK_RESUME( pxTCB );  // 调试跟踪：记录任务恢复事件

                    /* 就绪链表可以在调度器挂起时访问，因为当前在临界区内 */
                    // 从挂起链表中移除任务的状态链表项（xStateListItem）
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    // 将任务加入就绪链表（根据其优先级放入应的就绪链表）
                    prvAddTaskToReadyList( pxTCB );

                    /* 触发任意核心的任务切换（如果启用抢占式调度）：
                     * 此次切换可能不会让刚恢复的任务立即运行，
                     * 但能确保任务链表状态正确，为下一次切换做准备 */
                    taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（任务未挂起时执行）
                }
            }
            taskEXIT_CRITICAL();  // 退出临界区
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（参数无效时执行）
        }

        traceRETURN_vTaskResume();  // 调试跟踪：函数返回
    }

#endif /* INCLUDE_vTaskSuspend */
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
        BaseType_t xYieldRequired = pdFALSE;
        TCB_t * const pxTCB = xTaskToResume;
        UBaseType_t uxSavedInterruptStatus;

        traceENTER_xTaskResumeFromISR( xTaskToResume );

        configASSERT( xTaskToResume );

        /* RTOS端口如果支持中断嵌套，会有一个"最大系统调用中断优先级"的概念。
         * 高于这个优先级的中断会永久使能，即使RTOS内核处于临界区，
         * 但这些中断不能调用任何FreeRTOS API函数。如果在FreeRTOSConfig.h中定义了configASSERT()，
         * 那么当从一个被分配了高于配置的最大系统调用优先级的中断中调用FreeRTOS API函数时，
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID()会导致断言失败。
         * 只有以FromISR结尾的FreeRTOS函数可以从优先级等于或低于
         * 最大系统调用中断优先级的中断中调用。FreeRTOS维护一个独立的中断安全API，
         * 以确保中断进入尽可能快速和简单。更多信息（虽然是Cortex-M特定的）
         * 可在以下链接找到：https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        // 从ISR进入临界区，保存中断状态
        //这是 FreeRTOS 为中断服务程序（ISR） 设计的专用临界区进入函数，与普通任务中使用的 taskENTER_CRITICAL() 不同：
        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                // 检查就绪链表是否可访问（即调度器是否未被挂起）
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
                {
                    /* 就绪链表可访问，因此直接将任务从挂起链表移到就绪链表 */
                    #if ( configNUMBER_OF_CORES == 1 )
                    {
                        /* Ready lists can be accessed so move the task from the
                         * suspended list to the ready list directly. */
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                        {
                            xYieldRequired = pdTRUE;

                            /* Mark that a yield is pending in case the user is not
                             * using the return value to initiate a context switch
                             * from the ISR using the port specific portYIELD_FROM_ISR(). */
                            /* 标记有一个待处理的切换，以防用户没有使用返回值
                             * 通过特定于端口的portYIELD_FROM_ISR()从ISR启动上下文切换 */
                            xYieldPendings[ 0 ] = pdTRUE;
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
                }
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
                }

                #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_PREEMPTION == 1 ) )
                {
                    prvYieldForTask( pxTCB );

                    if( xYieldPendings[ portGET_CORE_ID() ] != pdFALSE )
                    {
                        xYieldRequired = pdTRUE;
                    }
                }
                #endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_PREEMPTION == 1 ) ) */
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_xTaskResumeFromISR( xYieldRequired );

        return xYieldRequired;
    }

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

// 静态函数：创建FreeRTOS的空闲任务（每个核心对应一个空闲任务，调度器启动前必须创建）
static BaseType_t prvCreateIdleTasks( void )
{
    BaseType_t xReturn = pdPASS;          // 函数返回值（pdPASS表示创建成功，pdFAIL表示失败）
    BaseType_t xCoreID;                   // 核心ID（用于遍历所有核心，为每个核心创建空闲任务）
    char cIdleName[ configMAX_TASK_NAME_LEN ];  // 空闲任务名称缓冲区（长度由配置宏定义）
    TaskFunction_t pxIdleTaskFunction = NULL;   // 指向空闲任务函数的指针（单核/多核函数不同）
    BaseType_t xIdleTaskNameIndex;        // 空闲任务名称的索引（用于拼接名称后缀）

    // 第一步：初始化空闲任务的基础名称（从配置宏configIDLE_TASK_NAME复制）
    for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )
    {
        // 将配置的空闲任务名称（如"IDLE"）逐字符复制到缓冲区
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];

        /* 若名称提前结束（遇到字符串结束符'\0'），则停止复制
         * 避免复制超出名称长度的无效内存（极端情况下内存不可访问） */
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
        {
            break;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（名称未结束时执行）
        }
    }

    /* 为每个核心创建空闲任务，空闲任务优先级固定为最低（tskIDLE_PRIORITY，默认0） */
    // 第二步：遍历所有核心，为每个核心创建对应的空闲任务
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
    {
        // 选择当前核心对应的空闲任务函数（单核与多核不同）
        #if ( configNUMBER_OF_CORES == 1 )  // 单核系统
        {
            // 单核仅需一个空闲任务，函数为prvIdleTask（处理内存回收等核心逻辑）
            pxIdleTaskFunction = prvIdleTask;
        }
        #else /* 多核系统（configNUMBER_OF_CORES > 1） */
        {
            /* 多核SMP（对称多处理）中，除了主空闲任务，还需创建"被动空闲任务"
             * 确保每个核心无其他任务时，都有空闲任务可执行 */
            if( xCoreID == 0 )  // 核心0：使用主空闲任务函数（处理全局逻辑，如内存回收）
            {
                pxIdleTaskFunction = prvIdleTask;
            }
            else  // 其他核心：使用被动空闲任务函数（仅空转，无复杂逻辑）
            {
                pxIdleTaskFunction = prvPassiveIdleTask;
            }
        }
        #endif /* configNUMBER_OF_CORES == 1 */

        // 多核系统：为空闲任务名称添加核心编号后缀（如"IDLE0"、"IDLE1"），区分不同核心的空闲任务
        #if ( configNUMBER_OF_CORES > 1 )
        {
            /* 若名称缓冲区有剩余空间，在基础名称后追加核心编号（如0、1） */
            if( xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN )
            {
                // 将核心ID（数字）转为字符（如xCoreID=1 → '1'），追加到名称后
                cIdleName[ xIdleTaskNameIndex ] = ( char ) ( xCoreID + '0' );

                /* 若还有空间，在编号后添加字符串结束符'\0'，确保名称合法 */
                if( ( xIdleTaskNameIndex + 1 ) < ( BaseType_t ) configMAX_TASK_NAME_LEN )
                {
                    cIdleName[ xIdleTaskNameIndex + 1 ] = '\0';
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无空间加结束符时执行）
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无空间加编号时执行）
            }
        }
        #endif /* configNUMBER_OF_CORES > 1 */

        // 分支1：使用静态内存分配创建空闲任务（configSUPPORT_STATIC_ALLOCATION == 1）
        #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
        {
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;  // 空闲任务TCB（任务控制块）的静态内存缓冲区
            StackType_t * pxIdleTaskStackBuffer = NULL;  // 空闲任务栈的静态内存缓冲区
            configSTACK_DEPTH_TYPE uxIdleTaskStackSize;  // 空闲任务栈的大小

            /* 空闲任务使用应用层提供的静态内存，先获取内存地址，再创建任务 */
            #if ( configNUMBER_OF_CORES == 1 )  // 单核系统
            {
                // 调用应用层实现的函数，获取空闲任务的TCB、栈缓冲区和栈大小
                vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &uxIdleTaskStackSize );
            }
            #else  // 多核系统
            {
                if( xCoreID == 0 )  // 核心0：获取主空闲任务的静态内存
                {
                    vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &uxIdleTaskStackSize );
                }
                else  // 其他核心：获取被动空闲任务的静态内存（需传入核心索引，区分不同核心）
                {
                    vApplicationGetPassiveIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &uxIdleTaskStackSize, ( BaseType_t ) ( xCoreID - 1 ) );
                }
            }
            #endif /* configNUMBER_OF_CORES == 1 */

            // 调用静态内存创建任务的API（xTaskCreateStatic），创建空闲任务
            xIdleTaskHandles[ xCoreID ] = xTaskCreateStatic( 
                pxIdleTaskFunction,    // 空闲任务函数（prvIdleTask或prvPassiveIdleTask）
                cIdleName,             // 空闲任务名称（如"IDLE0"）
                uxIdleTaskStackSize,   // 空闲任务栈大小（应用层指定）
                ( void * ) NULL,       // 任务参数（空闲任务无需参数，传NULL）
                portPRIVILEGE_BIT,     // 任务优先级（最低优先级0 + 特权模式位，确保空闲任务为特权态）
                pxIdleTaskStackBuffer, // 任务栈静态缓冲区
                pxIdleTaskTCBBuffer    // 任务TCB静态缓冲区
            );

            // 检查空闲任务是否创建成功（xTaskCreateStatic返回非NULL表示成功）
            if( xIdleTaskHandles[ xCoreID ] != NULL )
            {
                xReturn = pdPASS;  // 标记当前核心任务创建成功
            }
            else
            {
                xReturn = pdFAIL;  // 标记当前核心任务创建失败
            }
        }
        #else /* 分支2：使用动态内存分配创建空闲任务（configSUPPORT_STATIC_ALLOCATION == 0） */
        {
            /* 空闲任务使用FreeRTOS堆的动态内存，调用动态创建任务的API（xTaskCreate） */
            xReturn = xTaskCreate(
                pxIdleTaskFunction,    // 空闲任务函数
                cIdleName,             // 空闲任务名称
                configMINIMAL_STACK_SIZE,  // 空闲任务栈大小（使用配置的最小栈大小）
                ( void * ) NULL,       // 任务参数（NULL）
                portPRIVILEGE_BIT,     // 任务优先级（最低优先级0 + 特权模式位）
                &xIdleTaskHandles[ xCoreID ]  // 输出参数：存储空闲任务句柄的数组
            );
        }
        #endif /* configSUPPORT_STATIC_ALLOCATION */

        /* 若任意一个核心的空闲任务创建失败，立即退出循环（无需继续创建其他核心的任务） */
        if( xReturn == pdFAIL )
        {
            break;
        }
        else
        {
            #if ( configNUMBER_OF_CORES == 1 )  // 单核系统无需绑定核心
            {
                mtCOVERAGE_TEST_MARKER();
            }
            #else  // 多核系统：将空闲任务绑定到对应的核心（调度器启动前完成绑定）
            {
                /* 在SMP调度器启动前，为每个空闲任务指定运行的核心 */
                xIdleTaskHandles[ xCoreID ]->xTaskRunState = xCoreID;  // 任务绑定到当前核心
                pxCurrentTCBs[ xCoreID ] = xIdleTaskHandles[ xCoreID ];  // 标记当前核心的初始运行任务为空闲任务
            }
            #endif
        }
    }

    return xReturn;  // 返回创建结果（pdPASS表示所有核心任务创建成功，pdFAIL表示至少一个失败）
}

/*-----------------------------------------------------------*/

// 函数：启动FreeRTOS调度器（调度器启动后，任务才会开始被调度执行）
void vTaskStartScheduler( void )
{
    BaseType_t xReturn;  // 用于存储函数返回值（判断空闲任务、定时器任务是否创建成功）

    traceENTER_vTaskStartScheduler();  // 调试跟踪：调度器启动函数入口

    // 若启用“核心亲和性”（任务绑定特定核心）且为多核系统
    #if ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 )
    {
        /* 合法性检查：确保UBaseType_t类型的位数 ≥ 核心数（核心亲和性需用位掩码表示，位数不足会导致绑定失败） */
        configASSERT( ( sizeof( UBaseType_t ) * taskBITS_PER_BYTE ) >= configNUMBER_OF_CORES );
    }
    #endif /* ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) */

    // 1. 创建空闲任务（每个核心都需要一个空闲任务，用于核心无其他就绪任务时执行）
    xReturn = prvCreateIdleTasks();

    // 若启用软件定时器功能
    #if ( configUSE_TIMERS == 1 )
    {
        // 若空闲任务创建成功，再创建定时器服务任务（处理软件定时器的超时回调）
        if( xReturn == pdPASS )
        {
            xReturn = xTimerCreateTimerTask();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（空闲任务创建失败时执行）
        }
    }
    #endif /* configUSE_TIMERS */

    // 若空闲任务（+定时器任务，若启用）创建成功，继续启动流程
    if( xReturn == pdPASS )
    {
        /* 仅当用户定义了FREERTOS_TASKS_C_ADDITIONS_INIT()宏时，才调用此函数
         * 用于用户自定义的初始化操作（如扩展任务功能的额外配置） */
        #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
        {
            freertos_tasks_c_additions_init();
        }
        #endif

        /* 此处禁用中断：确保在调用xPortStartScheduler()之前/过程中，不会触发时钟节拍中断
         * （已创建任务的栈中存储了“中断使能”的状态字，第一个任务运行时会自动重新使能中断） */
        portDISABLE_INTERRUPTS();

        // 若启用C运行时TLS（线程局部存储）支持
        #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
        {
            /* 将C运行时的TLS块切换为“第一个要运行的任务”的TLS块
             * （确保线程局部变量能正确绑定到任务上下文） */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        // 2. 初始化调度器核心变量
        xNextTaskUnblockTime = portMAX_DELAY;  // 初始化“下一个任务解阻塞时间”为最大值（表示暂无任务延迟）
        xSchedulerRunning = pdTRUE;            // 标记“调度器已启动”
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  // 初始化Tick计数器（默认0，即系统启动时刻）

        /* 若启用“任务运行时统计”（configGENERATE_RUN_TIME_STATS == 1）：
         * 此宏用于配置硬件定时器/计数器，作为运行时统计的时间基准
         * （后续可通过API获取每个任务的CPU占用率，如vTaskGetRunTimeStats()）
         * 注意：若禁用统计功能但定义了此宏，会导致编译失败 */
        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

        traceTASK_SWITCHED_IN();  // 调试跟踪：标记“第一个任务即将切入运行”

        /* 配置时钟节拍中断是硬件相关操作，因此实现在移植层（portable）中 */

        /* xPortStartScheduler()的返回值通常无需处理（多数移植中此函数不会返回）
         * 此处强转为void避免编译器警告 */
        // 3. 调用移植层函数，启动调度循环（核心步骤）
        ( void ) xPortStartScheduler();

        /* 多数情况下，xPortStartScheduler()不会返回：
         * - 若返回pdTRUE：堆内存不足，无法创建空闲任务或定时器任务（理论上此处已提前检查，不会触发）
         * - 若返回pdFALSE：应用层调用了xTaskEndScheduler()（多数移植不实现此函数，因无“返回点”） */
    }
    else
    {
        /* 仅当内核启动失败时会执行到此处：
         * 原因是FreeRTOS堆内存不足，无法创建空闲任务或定时器任务 */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    }

    /* 若INCLUDE_xTaskGetIdleTaskHandle设为0（不使用空闲任务句柄），
     * 此句用于避免编译器“变量未使用”警告 */
    ( void ) xIdleTaskHandles;

    /* OpenOCD（调试工具）会使用uxTopUsedPriority进行线程调试，
     * 此句用于避免编译器将其优化掉（内核已不再使用此变量） */
    ( void ) uxTopUsedPriority;

    traceRETURN_vTaskStartScheduler();  // 调试跟踪：调度器启动函数返回（多数情况不会执行到此处）
}
/*-----------------------------------------------------------*/

// 函数：终止FreeRTOS调度器（停止多任务调度，恢复到调度器启动前的状态）
void vTaskEndScheduler( void )
{
    traceENTER_vTaskEndScheduler();  // 调试跟踪：函数入口

    // 若启用任务删除功能（INCLUDE_vTaskDelete == 1），则先清理内核创建的系统任务
    #if ( INCLUDE_vTaskDelete == 1 )
    {
        BaseType_t xCoreID;  // 核心ID（用于遍历所有核心的空闲任务）

        // 若启用软件定时器功能，先删除内核创建的定时器服务任务
        #if ( configUSE_TIMERS == 1 )
        {
            /* 删除内核创建的定时器服务任务
             * xTimerGetTimerDaemonTaskHandle()：获取定时器服务任务的句柄 */
            vTaskDelete( xTimerGetTimerDaemonTaskHandle() );
        }
        #endif /* configUSE_TIMERS == 1 */

        /* 遍历所有核心，删除内核为每个核心创建的空闲任务 */
        for( xCoreID = 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
        {
            vTaskDelete( xIdleTaskHandles[ xCoreID ] );  // 通过空闲任务句柄数组删除对应核心的空闲任务
        }

        /* 注释说明：
         * 空闲任务的职责之一是回收“等待删除的任务”（xTasksWaitingTermination链表中的任务）的资源；
         * 现在空闲任务已被删除，无法再自动回收资源，因此需要手动调用函数清理这些任务的资源。 */
        // 手动清理“等待删除的任务”的资源（如TCB、栈内存）
        prvCheckTasksWaitingTermination();
    }
    #endif /* INCLUDE_vTaskDelete == 1 */

    /* 注释说明：
     * 1. 停止调度器相关的中断（如时钟节拍Tick中断，避免中断触发调度逻辑）；
     * 2. 调用移植层的调度器终止函数，恢复原始的中断服务程序（ISR）（若移植层做了中断重定向）；
     * 3. 移植层必须确保中断使能位的状态正确（通常恢复为调度器启动前的状态）。 */
    portDISABLE_INTERRUPTS();  // 禁用中断（防止终止过程中被调度相关中断打断）
    xSchedulerRunning = pdFALSE;  // 标记“调度器已停止”（后续API会通过此变量判断调度器状态）

    /* 注释说明：
     * 1. 此函数必须从任务上下文调用（不能在中断上下文调用）；
     * 2. 应用层需在调度器停止后，手动删除“调用此函数的任务”（因为该任务仍处于运行状态）。 */
    // 调用移植层的调度器终止函数（硬件相关操作，如恢复上下文、停止Tick定时器）
    vPortEndScheduler();

    traceRETURN_vTaskEndScheduler();  // 调试跟踪：函数返回（多数移植中此函数不会执行到此处）
}
/*----------------------------------------------------------*/

// 函数：挂起所有任务调度（挂起调度器，使任务切换暂时失效）
void vTaskSuspendAll( void )
{
    traceENTER_vTaskSuspendAll();  // 调试跟踪：函数入口

    // 单核系统（核心数==1）的实现逻辑
    #if ( configNUMBER_OF_CORES == 1 )
    {
        /* 注释说明：
         * 1. 由于uxSchedulerSuspended是BaseType_t类型（原子操作可保证安全），此处无需进入临界区；
         * 2. 关于为何无需临界区的详细解释，可参考FreeRTOS论坛链接：https://goo.gl/wu4acr */

        /* portSOFTWARE_BARRIER()仅在“非实时的模拟/仿真平台”中实现，
         * 作用是阻止编译器对“屏障前后的代码”进行重排序（保证代码执行顺序）。 */
        portSOFTWARE_BARRIER();  // 软件屏障：防止编译器乱序优化

        /* 注释说明：
         * 1. 当uxSchedulerSuspended不为0时，表示调度器已被挂起；
         * 2. 使用“自增”操作支持嵌套调用（多次调用vTaskSuspendAll()，需对应次数的vTaskResumeAll()才能恢复）。 */
        // 调度器挂起计数器自增（支持嵌套挂起）
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );

        /* 对“需要实时行为的平台”，此宏用于：
         * 1. 阻止编译器重排序；
         * 2. 阻止CPU乱序执行（通过内存屏障指令），确保自增结果立即对其他代码可见。 */
        portMEMORY_BARRIER();  // 内存屏障：确保自增操作的结果立即生效
    }
    #else /* 多核系统（核心数>1）的实现逻辑 */
    {
        UBaseType_t ulState;  // 用于保存中断屏蔽状态（后续恢复用）

        /* 此函数只能从任务上下文调用，不能在中断上下文调用（断言检查） */
        portASSERT_IF_IN_ISR();

        // 若调度器正在运行（xSchedulerRunning == pdTRUE），才执行挂起逻辑
        if( xSchedulerRunning != pdFALSE )
        {
            /* 注释说明：
             * 1. 对uxSchedulerSuspended的写操作必须同时受“任务锁”和“ISR锁”保护；
             * 2. 必须先禁用中断，防止此任务在“获取锁并自增计数器”前被中断并切换上下文；
             * 3. 在释放ISR锁并自增计数器后，可安全重新启用中断（此时已阻止上下文切换）。 */
            ulState = portSET_INTERRUPT_MASK();  // 禁用中断，返回当前中断状态

            /* 此函数绝不能在临界区内调用（断言检查，避免嵌套锁导致死锁） */
            configASSERT( portGET_CRITICAL_NESTING_COUNT() == 0 );

            /* portSOFTWARE_BARRIER()仅在模拟平台实现，防止编译器乱序优化 */
            portSOFTWARE_BARRIER();

            portGET_TASK_LOCK();  // 获取任务锁（防止其他任务同时修改调度器状态）

            /* 注释说明：
             * 1. 在自增uxSchedulerSuspended前，先调用prvCheckForRunStateChange()；
             * 2. 目的是：在调度器即将被挂起时，处理可能的任务状态变更（如就绪任务优先级变化）。 */
            if( uxSchedulerSuspended == 0U )  // 若调度器当前未被挂起（首次挂起）
            {
                prvCheckForRunStateChange();  // 检查并处理任务状态变更
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（嵌套挂起时执行）
            }

            portGET_ISR_LOCK();  // 获取ISR锁（防止中断上下文修改调度器状态）

            /* 注释说明：
             * 1. 当uxSchedulerSuspended不为0时，表示调度器已被挂起；
             * 2. 自增操作支持嵌套调用（多次挂起需对应次数的恢复）。 */
            ++uxSchedulerSuspended;  // 调度器挂起计数器自增
            portRELEASE_ISR_LOCK();  // 释放ISR锁

            portCLEAR_INTERRUPT_MASK( ulState );  // 恢复中断状态（重新启用中断）
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（调度器未运行时执行）
        }
    }
    #endif /* configNUMBER_OF_CORES == 1 */

    traceRETURN_vTaskSuspendAll();  // 调试跟踪：函数返回
}

/*----------------------------------------------------------*/

#if ( configUSE_TICKLESS_IDLE != 0 )

    static TickType_t prvGetExpectedIdleTime( void )
    {
        TickType_t xReturn;
        UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;

        /* uxHigherPriorityReadyTasks takes care of the case where
         * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
         * task that are in the Ready state, even though the idle task is
         * running. */
        #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
        {
            if( uxTopReadyPriority > tskIDLE_PRIORITY )
            {
                uxHigherPriorityReadyTasks = pdTRUE;
            }
        }
        #else
        {
            const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;

            /* When port optimised task selection is used the uxTopReadyPriority
             * variable is used as a bit map.  If bits other than the least
             * significant bit are set then there are tasks that have a priority
             * above the idle priority that are in the Ready state.  This takes
             * care of the case where the co-operative scheduler is in use. */
            if( uxTopReadyPriority > uxLeastSignificantBit )
            {
                uxHigherPriorityReadyTasks = pdTRUE;
            }
        }
        #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */

        if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
        {
            xReturn = 0;
        }
        else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1U )
        {
            /* There are other idle priority tasks in the ready state.  If
             * time slicing is used then the very next tick interrupt must be
             * processed. */
            xReturn = 0;
        }
        else if( uxHigherPriorityReadyTasks != pdFALSE )
        {
            /* There are tasks in the Ready state that have a priority above the
             * idle priority.  This path can only be reached if
             * configUSE_PREEMPTION is 0. */
            xReturn = 0;
        }
        else
        {
            xReturn = xNextTaskUnblockTime;
            xReturn -= xTickCount;
        }

        return xReturn;
    }

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

// 函数：恢复所有任务调度（与vTaskSuspendAll配对，解除调度器挂起状态）
BaseType_t xTaskResumeAll( void )
{
    TCB_t * pxTCB = NULL;               // 指向任务控制块（TCB）的指针，用于处理就绪任务
    BaseType_t xAlreadyYielded = pdFALSE;  // 返回值：标记是否已触发任务切换（pdTRUE=已切换）

    traceENTER_xTaskResumeAll();  // 调试跟踪：函数入口

    // 多核系统：仅当调度器正在运行时，才执行恢复逻辑
    #if ( configNUMBER_OF_CORES > 1 )
        if( xSchedulerRunning != pdFALSE )
    #endif
    {
        /* 注释说明：
         * 1. 调度器挂起期间，中断可能导致任务从“事件等待链表”（如信号量、队列链表）中移除；
         * 2. 被移除的任务不会直接加入就绪链表，而是先放入“待处理就绪链表”（xPendingReadyList）；
         * 3. 调度器恢复后，需将待处理就绪链表中的任务移到正确的就绪链表，确保其能被调度。 */
        taskENTER_CRITICAL();  // 进入临界区，确保任务链表操作的原子性
        {
            BaseType_t xCoreID;  // 当前核心ID（用于多核场景下的核心专属操作）
            xCoreID = ( BaseType_t ) portGET_CORE_ID();  // 获取当前执行此函数的核心ID

            /* 断言：uxSchedulerSuspended不能为0（确保调用此函数前，调度器已被挂起）
             * 防止“未挂起却调用恢复”的非法操作 */
            configASSERT( uxSchedulerSuspended != 0U );

            // 调度器挂起计数器自减（嵌套挂起时，需减到0才真正恢复调度）
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
            portRELEASE_TASK_LOCK();  // 释放任务锁（多核场景下，之前挂起时获取的锁）

            // 若计数器减为0，说明调度器要完全恢复运行（非嵌套挂起的中间状态）
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
            {
                // 若系统中存在任务（uxCurrentNumberOfTasks > 0），才处理待就绪任务
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
                {
                    /* 第一步：将“待处理就绪链表”（xPendingReadyList）中的所有任务，移到正确的就绪链表 */
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )  // 循环直到待处理链表为空
                    {
                        /* MISRA规则兼容注释：空指针赋值相关说明，详见链接 */
                        /* 从待处理就绪链表的头部获取任务的TCB */
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
                        // 从任务的“事件链表项”（xEventListItem）所在链表中移除（解除事件等待关联）
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                        portMEMORY_BARRIER();  // 内存屏障：确保链表移除操作的结果立即生效
                        // 从任务的“状态链表项”（xStateListItem）所在链表中移除（解除原状态关联）
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                        // 将任务加入正确的就绪链表（根据任务优先级，放入对应的pxReadyTasksLists链表）
                        prvAddTaskToReadyList( pxTCB );

                        // 单核系统：检查恢复的任务是否需要触发切换
                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            /* 若恢复的任务优先级 > 当前运行任务的优先级，需标记“待切换” */
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                            {
                                xYieldPendings[ xCoreID ] = pdTRUE;  // 标记当前核心需要任务切换
                            }
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（优先级不高时执行）
                            }
                        }
                        #else /* 多核系统：无需额外标记，任务加入待处理链表时已触发过切换检查 */
                        {
                            /* 注释说明：多核场景下，任务加入待处理就绪链表时，已触发对应核心的切换检查；
                             * 若当前核心需切换，vTaskSwitchContext()已调用并标记xYieldPendings */
                        }
                        #endif /* configNUMBER_OF_CORES == 1 */
                    }

                    // 若有任务从待处理链表移出，需重置“下一个任务解阻塞时间”
                    if( pxTCB != NULL )
                    {
                        /* 注释说明：
                         * 调度器挂起期间，任务解除阻塞可能导致“下一个解阻塞时间”未及时更新；
                         * 此时重置该时间，确保低功耗Tickless模式下，系统不会因无效时间误唤醒，优化功耗。 */
                        prvResetNextTaskUnblockTime();
                    }

                    /* 第二步：处理调度器挂起期间积累的Tick（时钟节拍）
                     * 1. 确保Tick计数不丢失，避免任务延迟时间计算错误；
                     * 2. 触发延迟任务的超时唤醒（如vTaskDelay的任务到点恢复）。 */
                    {
                        TickType_t xPendedCounts = xPendedTicks; /* 复制积累的Tick数（避免volatile变量多次读取） */

                        // 若存在积累的Tick，逐个处理
                        if( xPendedCounts > ( TickType_t ) 0U )
                        {
                            do
                            {
                                /* 调用xTaskIncrementTick()处理单个Tick：
                                 * - 更新系统Tick计数；
                                 * - 检查延迟任务是否超时，超时则唤醒；
                                 * - 返回pdTRUE表示需要触发任务切换（如高优先级任务被唤醒）。 */
                                if( xTaskIncrementTick() != pdFALSE )
                                {
                                    /* 注释说明：多核场景下，xTaskIncrementTick()会中断其他核心；
                                     * 标记当前核心需要任务切换。 */
                                    xYieldPendings[ xCoreID ] = pdTRUE;
                                }
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无需切换时执行）
                                }

                                xPendedCounts--;  // 处理完一个Tick，计数减1
                            } while( xPendedCounts > ( TickType_t ) 0U );

                            xPendedTicks = 0;  // 重置积累的Tick数
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无积累Tick时执行）
                        }
                    }

                    /* 第三步：若当前核心标记了“待切换”，触发任务切换（仅抢占式调度有效） */
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
                    {
                        // 若启用抢占式调度，标记“已触发切换”
                        #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                        #endif /* configUSE_PREEMPTION != 0 */

                        // 单核系统：触发当前核心的任务切换
                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
                        }
                        #endif /* configNUMBER_OF_CORES == 1 */
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无需切换时执行）
                    }
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（嵌套挂起未完全恢复时执行）
            }
        }
        taskEXIT_CRITICAL();  // 退出临界区
    }

    traceRETURN_xTaskResumeAll( xAlreadyYielded );  // 调试跟踪：函数返回，携带“是否已切换”结果

    return xAlreadyYielded;  // 返回结果：pdTRUE=已触发任务切换，pdFALSE=未切换
}
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    traceENTER_xTaskGetTickCount();

    /* Critical section required if running on a 16 bit processor. */
    /* 如果运行在16位处理器上，需要临界区保护 */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
    }
    portTICK_TYPE_EXIT_CRITICAL();

    traceRETURN_xTaskGetTickCount( xTicks );

    return xTicks;
}
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    TickType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    traceENTER_xTaskGetTickCountFromISR();

    /* RTOS ports that support interrupt nesting have the concept of a maximum
     * system call (or maximum API call) interrupt priority.  Interrupts that are
     * above the maximum system call priority are kept permanently enabled, even
     * when the RTOS kernel is in a critical section, but cannot make any calls to
     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
     * failure if a FreeRTOS API function is called from an interrupt that has been
     * assigned a priority above the configured maximum system call priority.
     * Only FreeRTOS functions that end in FromISR can be called from interrupts
     * that have been assigned a priority at or (logically) below the maximum
     * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    traceRETURN_xTaskGetTickCountFromISR( xReturn );

    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    traceENTER_uxTaskGetNumberOfTasks();

    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    traceRETURN_uxTaskGetNumberOfTasks( uxCurrentNumberOfTasks );

    return uxCurrentNumberOfTasks;
}
/*-----------------------------------------------------------*/


char * pcTaskGetName( TaskHandle_t xTaskToQuery )
{
    TCB_t * pxTCB;

    traceENTER_pcTaskGetName( xTaskToQuery );

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    configASSERT( pxTCB );

    traceRETURN_pcTaskGetName( &( pxTCB->pcTaskName[ 0 ] ) );

    return &( pxTCB->pcTaskName[ 0 ] );
}
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetHandle == 1 )
    static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
                                                     const char pcNameToQuery[] )
    {
        TCB_t * pxReturn = NULL;
        TCB_t * pxTCB = NULL;
        UBaseType_t x;
        char cNextChar;
        BaseType_t xBreakLoop;
        const ListItem_t * pxEndMarker = listGET_END_MARKER( pxList );
        ListItem_t * pxIterator;

        /* This function is called with the scheduler suspended. */

        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
        {
            for( pxIterator = listGET_HEAD_ENTRY( pxList ); pxIterator != pxEndMarker; pxIterator = listGET_NEXT( pxIterator ) )
            {
                /* MISRA Ref 11.5.3 [Void pointer assignment] */
                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                /* coverity[misra_c_2012_rule_11_5_violation] */
                pxTCB = listGET_LIST_ITEM_OWNER( pxIterator );

                /* Check each character in the name looking for a match or
                 * mismatch. */
                xBreakLoop = pdFALSE;

                for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
                {
                    cNextChar = pxTCB->pcTaskName[ x ];

                    if( cNextChar != pcNameToQuery[ x ] )
                    {
                        /* Characters didn't match. */
                        xBreakLoop = pdTRUE;
                    }
                    else if( cNextChar == ( char ) 0x00 )
                    {
                        /* Both strings terminated, a match must have been
                         * found. */
                        pxReturn = pxTCB;
                        xBreakLoop = pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    if( xBreakLoop != pdFALSE )
                    {
                        break;
                    }
                }

                if( pxReturn != NULL )
                {
                    /* The handle has been found. */
                    break;
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return pxReturn;
    }

#endif /* INCLUDE_xTaskGetHandle */
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetHandle == 1 )

    TaskHandle_t xTaskGetHandle( const char * pcNameToQuery )
    {
        UBaseType_t uxQueue = configMAX_PRIORITIES; // 初始化优先级队列索引为最大优先级
        TCB_t * pxTCB;

        traceENTER_xTaskGetHandle( pcNameToQuery );

        /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
        configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );

        vTaskSuspendAll();
        {
            /* Search the ready lists. */
            do
            {
                uxQueue--; // 从最高优先级开始，依次降低优先级
                // 在当前优先级的就绪链表中搜索指定名称的任务
                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );

                if( pxTCB != NULL )
                {
                    /* Found the handle. */
                    break;
                }
            } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );  // 直到搜索到空闲优先级

            /* Search the delayed lists. */
            // 如果在就绪链表中未找到
            if( pxTCB == NULL )
            {
                /* 搜索延迟链表 */
                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
            }

            if( pxTCB == NULL )
            {
                // 在溢出延迟任务链表中搜索
                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
            }

            #if ( INCLUDE_vTaskSuspend == 1 )
            {
                if( pxTCB == NULL )
                {
                    /* Search the suspended list. */
                    /* 搜索挂起链表 */
                    pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
                }
            }
            #endif

            #if ( INCLUDE_vTaskDelete == 1 )
            {
                if( pxTCB == NULL )
                {
                    /* Search the deleted list. */
                    /* 搜索已删除任务链表 */
                    pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
                }
            }
            #endif
        }
        ( void ) xTaskResumeAll();

        traceRETURN_xTaskGetHandle( pxTCB );

        return pxTCB;
    }

#endif /* INCLUDE_xTaskGetHandle */
/*-----------------------------------------------------------*/

// 如果开启了静态内存分配支持（configSUPPORT_STATIC_ALLOCATION == 1），则编译此函数
#if ( configSUPPORT_STATIC_ALLOCATION == 1 )

    // 函数功能：获取静态创建的任务所使用的栈缓冲区和任务控制块（TCB）缓冲区地址
    // 参数：
    //   xTask：目标任务的句柄
    //   ppuxStackBuffer：输出参数，用于存储栈缓冲区的地址（通过指针的指针返回）
    //   ppxTaskBuffer：输出参数，用于存储任务控制块缓冲区的地址（通过指针的指针返回）
    // 返回值：pdTRUE表示成功获取；pdFALSE表示失败（如任务为动态创建）
    BaseType_t xTaskGetStaticBuffers( TaskHandle_t xTask,
                                      StackType_t **ppuxStackBuffer,
                                      StaticTask_t** ppxTaskBuffer )
    {
        BaseType_t xReturn;  // 用于存储函数返回结果
        TCB_t * pxTCB;       // 指向任务控制块（TCB）的指针

        traceENTER_xTaskGetStaticBuffers( xTask, ppuxStackBuffer, ppxTaskBuffer );  // 调试跟踪：函数入口

        // 断言检查：确保输出参数不为空指针（避免后续空指针操作导致崩溃）
        configASSERT( ppuxStackBuffer != NULL );
        configASSERT( ppxTaskBuffer != NULL );

        // 通过任务句柄获取对应的TCB指针（任务句柄本质是TCB指针的封装）
        pxTCB = prvGetTCBFromHandle( xTask );

        // 如果系统同时支持静态和动态内存分配（tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1）
        #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
        {
            // 检查任务的静态分配标记：栈和TCB均为静态分配
            if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB )
            {
                *ppuxStackBuffer = pxTCB->pxStack;  // 将栈缓冲区地址存入输出参数
                /* MISRA规则兼容注释：涉及未对齐访问的说明，详见链接 */
                /* 更多细节：https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-113 */
                /* coverity[misra_c_2012_rule_11_3_violation] */
                *ppxTaskBuffer = ( StaticTask_t * ) pxTCB;  // 将TCB缓冲区地址存入输出参数（强转为StaticTask_t*类型）
                xReturn = pdTRUE;  // 标记成功
            }
            // 检查任务的静态分配标记：仅栈为静态分配，TCB为动态分配
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
            {
                *ppuxStackBuffer = pxTCB->pxStack;  // 将栈缓冲区地址存入输出参数
                *ppxTaskBuffer = NULL;  // TCB为动态分配，无静态缓冲区，故设为NULL
                xReturn = pdTRUE;  // 标记成功
            }
            // 其他情况：任务为动态分配（ucStaticallyAllocated为其他值）
            else
            {
                xReturn = pdFALSE;  // 标记失败（动态分配的任务无静态缓冲区）
            }
        }
        #else /* 系统仅支持静态分配（tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 0） */
        {
            *ppuxStackBuffer = pxTCB->pxStack;  // 直接返回栈缓冲区地址
            *ppxTaskBuffer = ( StaticTask_t * ) pxTCB;  // 直接返回TCB缓冲区地址（强转为StaticTask_t*类型）
            xReturn = pdTRUE;  // 标记成功（所有任务都是静态分配的，必然能获取）
        }
        #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 */

        traceRETURN_xTaskGetStaticBuffers( xReturn );  // 调试跟踪：函数返回，携带返回值

        return xReturn;  // 返回结果
    }

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                      const UBaseType_t uxArraySize,
                                      configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )
    {
        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;

        traceENTER_uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );

        vTaskSuspendAll();
        {
            /* Is there a space in the array for each task in the system? */
            if( uxArraySize >= uxCurrentNumberOfTasks )
            {
                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Ready state. */
                do
                {
                    uxQueue--;
                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady ) );
                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );

                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Blocked state. */
                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked ) );
                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked ) );

                #if ( INCLUDE_vTaskDelete == 1 )
                {
                    /* Fill in an TaskStatus_t structure with information on
                     * each task that has been deleted but not yet cleaned up. */
                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted ) );
                }
                #endif

                #if ( INCLUDE_vTaskSuspend == 1 )
                {
                    /* Fill in an TaskStatus_t structure with information on
                     * each task in the Suspended state. */
                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended ) );
                }
                #endif

                #if ( configGENERATE_RUN_TIME_STATS == 1 )
                {
                    if( pulTotalRunTime != NULL )
                    {
                        #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                            portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
                        #else
                            *pulTotalRunTime = ( configRUN_TIME_COUNTER_TYPE ) portGET_RUN_TIME_COUNTER_VALUE();
                        #endif
                    }
                }
                #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
                {
                    if( pulTotalRunTime != NULL )
                    {
                        *pulTotalRunTime = 0;
                    }
                }
                #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        ( void ) xTaskResumeAll();

        traceRETURN_uxTaskGetSystemState( uxTask );

        return uxTask;
    }

#endif /* configUSE_TRACE_FACILITY */
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )

    #if ( configNUMBER_OF_CORES == 1 )
        TaskHandle_t xTaskGetIdleTaskHandle( void )
        {
            traceENTER_xTaskGetIdleTaskHandle();

            /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
             * started, then xIdleTaskHandles will be NULL. */
            configASSERT( ( xIdleTaskHandles[ 0 ] != NULL ) );

            traceRETURN_xTaskGetIdleTaskHandle( xIdleTaskHandles[ 0 ] );

            return xIdleTaskHandles[ 0 ];
        }
    #endif /* if ( configNUMBER_OF_CORES == 1 ) */

    TaskHandle_t xTaskGetIdleTaskHandleForCore( BaseType_t xCoreID )
    {
        traceENTER_xTaskGetIdleTaskHandleForCore( xCoreID );

        /* Ensure the core ID is valid. */
        configASSERT( taskVALID_CORE_ID( xCoreID ) == pdTRUE );

        /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
         * started, then xIdleTaskHandles will be NULL. */
        configASSERT( ( xIdleTaskHandles[ xCoreID ] != NULL ) );

        traceRETURN_xTaskGetIdleTaskHandleForCore( xIdleTaskHandles[ xCoreID ] );

        return xIdleTaskHandles[ xCoreID ];
    }

#endif /* INCLUDE_xTaskGetIdleTaskHandle */
/*----------------------------------------------------------*/

/* 条件编译应使用不等于0，而非等于1。
 * 这是为了确保当用户定义的低功耗模式实现要求configUSE_TICKLESS_IDLE
 * 设置为1以外的值时，vTaskStepTick()仍然可用。 */
#if ( configUSE_TICKLESS_IDLE != 0 ) // 如果启用了无滴答低功耗模式（无论具体值是多少）

    // 用于在低功耗模式后调整系统滴答计数
    void vTaskStepTick( TickType_t xTicksToJump )
    {
        TickType_t xUpdatedTickCount; // 声明变量用于存储更新后的滴答计数

        traceENTER_vTaskStepTick( xTicksToJump );

        /* 在滴答被抑制的时间段后修正滴答计数值。
         * 注意：这不会为每个步进的滴答调用滴答钩子函数。 */
        xUpdatedTickCount = xTickCount + xTicksToJump;
        configASSERT( xUpdatedTickCount <= xNextTaskUnblockTime );

        // 如果更新后的滴答计数等于下一个任务解除阻塞的时间
        if( xUpdatedTickCount == xNextTaskUnblockTime )
        {
            /* 安排xTickCount在调度器恢复时，在xTaskIncrementTick()中达到xNextTaskUnblockTime。
             * 这确保所有延迟任务在正确的时间恢复。 */
            configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
            configASSERT( xTicksToJump != ( TickType_t ) 0 );

            /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
            taskENTER_CRITICAL();
            {
                xPendedTicks++;
            }
            taskEXIT_CRITICAL();
            xTicksToJump--;
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        xTickCount += xTicksToJump;

        traceINCREASE_TICK_COUNT( xTicksToJump );
        traceRETURN_vTaskStepTick();
    }

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

// 用于快速追赶指定数量的系统滴答，返回是否发生了任务切换
BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    BaseType_t xYieldOccurred;

    traceENTER_xTaskCatchUpTicks( xTicksToCatchUp );

    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );

    /* 使用xPendedTicks来模拟在调度器挂起时发生了xTicksToCatchUp个滴答，
     * 这样这些滴答将在xTaskResumeAll()中被处理 */
    vTaskSuspendAll();

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    {
        xPendedTicks += xTicksToCatchUp;  // 将需要追赶的滴答数添加到挂起滴答计数中
    }
    taskEXIT_CRITICAL();
    xYieldOccurred = xTaskResumeAll(); // 恢复任务调度，并获取是否发生了任务切换的结果

    traceRETURN_xTaskCatchUpTicks( xYieldOccurred );

    return xYieldOccurred;
}
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskAbortDelay == 1 ) // 仅当启用"任务延迟中止"功能时编译该函数

    // 中止指定任务的延迟状态（将阻塞中的任务强制唤醒），返回操作结果
    BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
    {
        TCB_t * pxTCB = xTask;
        BaseType_t xReturn;

        traceENTER_xTaskAbortDelay( xTask );

        configASSERT( pxTCB );

        vTaskSuspendAll();
        {
            /* 只有当任务确实处于"阻塞状态（Blocked）"时，才能强制将其从阻塞状态移除 */
            if( eTaskGetState( xTask ) == eBlocked )
            {
                xReturn = pdPASS;

                /* 从阻塞链表中移除该任务的状态链表项。
                 * 由于调度器已挂起，中断不会修改xStateListItem（状态链表项仅调度器操作） */
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );

                 /* 任务是否同时在等待某个事件？（如信号量、事件组等）
                 * 如果是，还需将其从事件链表中移除。
                 * 注意：即使调度器挂起，中断仍可能操作事件链表项，因此需要临界区保护 */
                taskENTER_CRITICAL();
                {
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );

                        /* 设置延迟中止标记：告知任务"已被强制唤醒"，
                         * 避免任务唤醒后重新评估延迟时间并再次进入阻塞状态 */
                        pxTCB->ucDelayAborted = ( uint8_t ) pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                taskEXIT_CRITICAL();

                /* 将被强制唤醒的任务添加到对应的就绪链表中，使其进入就绪状态 */
                prvAddTaskToReadyList( pxTCB );

                /* 若禁用抢占式调度（configUSE_PREEMPTION=0），被唤醒的任务不会立即触发上下文切换，
                 * 需等待当前任务主动放弃CPU */
                #if ( configUSE_PREEMPTION == 1 )
                {
                    #if ( configNUMBER_OF_CORES == 1 )
                    {
                        /* 抢占式调度启用时，仅当被唤醒任务的优先级高于当前运行任务，才需要触发上下文切换 */
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                        {
                            /* 将"任务切换请求"挂起，待调度器恢复后执行切换。
                             * xYieldPendings[0]：单内核下的切换请求标志（多内核时为数组，对应每个核心） */
                            xYieldPendings[ 0 ] = pdTRUE;
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    #else /* #if ( configNUMBER_OF_CORES == 1 ) */
                    {
                        taskENTER_CRITICAL();
                        {
                            prvYieldForTask( pxTCB );
                        }
                        taskEXIT_CRITICAL();
                    }
                    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
                }
                #endif /* #if ( configUSE_PREEMPTION == 1 ) */
            }
            else
            {
                xReturn = pdFAIL;
            }
        }
        ( void ) xTaskResumeAll();

        traceRETURN_xTaskAbortDelay( xReturn );

        return xReturn;
    }

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

// 系统滴答计数递增函数，返回是否需要触发上下文切换（pdTRUE=需要切换，pdFALSE=无需切换）
BaseType_t xTaskIncrementTick( void )
{
    TCB_t * pxTCB;  // 指向任务控制块（TCB）的指针，用于处理超时任务
    TickType_t xItemValue;  // 存储任务的唤醒时间（从任务状态链表项中获取）
    BaseType_t xSwitchRequired = pdFALSE;  // 返回值：标记是否需要触发任务切换

    // 多核+抢占式调度场景：存储每个核心是否需要触发切换的标记
    #if ( configUSE_PREEMPTION == 1 ) && ( configNUMBER_OF_CORES > 1 )
    BaseType_t xYieldRequiredForCore[ configNUMBER_OF_CORES ] = { pdFALSE };
    #endif /* ( configUSE_PREEMPTION == 1 ) && ( configNUMBER_OF_CORES > 1 ) */

    traceENTER_xTaskIncrementTick();  // 调试跟踪：函数入口

    /* 注释说明：
     * 1. 此函数由移植层的滴答中断服务程序（ISR）调用（每次滴答中断触发一次）；
     * 2. 作用是：递增系统滴答计数，检查是否有任务因超时需从阻塞态唤醒。 */
    traceTASK_INCREMENT_TICK( xTickCount );  // 调试跟踪：记录当前滴答计数

    /* 注释说明：
     * 1. 每次滴答中断都需递增系统滴答计数；
     * 2. 仅核心0负责递增全局滴答计数（xTickCount）；
     * 3. 若调度器已挂起（uxSchedulerSuspended > 0），则不递增xTickCount，而是递增挂起滴答计数（xPendedTicks）；
     * 4. 挂起的滴答会在调度器恢复（xTaskResumeAll）时由调用恢复函数的核心统一处理。 */
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )  // 调度器未挂起：正常处理滴答
    {
        /* 小优化：将“当前滴答+1”的结果存入常量，避免后续代码重复计算 */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;

        /* 1. 递增全局滴答计数（xTickCount）；
         * 2. 若计数回绕到0（如32位TickType_t从0xFFFFFFFF变为0），需切换延迟任务链表，
         *    避免回绕后唤醒逻辑错误（通过taskSWITCH_DELAYED_LISTS()实现）。 */
        xTickCount = xConstTickCount;

        if( xConstTickCount == ( TickType_t ) 0U )  // 滴答计数回绕
        {
            // 切换延迟链表：将pxDelayedTaskList（当前延迟链表）与pxOverflowDelayedTaskList（溢出延迟链表）互换
            taskSWITCH_DELAYED_LISTS();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（未回绕时执行）
        }

        /* 检查当前滴答是否达到“下一个任务解阻塞时间”（xNextTaskUnblockTime）：
         * 若达到，说明有延迟任务超时，需唤醒并移到就绪链表；
         * 延迟链表中的任务按唤醒时间升序排列，一旦遇到未超时任务，后续任务均未超时，可终止遍历。 */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )  // 无限循环，直到无超时任务或延迟链表为空
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )  // 延迟链表为空
                {
                    /* 无延迟任务，将xNextTaskUnblockTime设为最大值（portMAX_DELAY），
                     * 确保下次滴答中断时，无需进入此遍历逻辑（优化性能） */
                    xNextTaskUnblockTime = portMAX_DELAY;
                    break;  // 退出循环
                }
                else  // 延迟链表非空，处理头部任务（唤醒时间最早的任务）
                {
                    /* 获取延迟链表头部任务的TCB（listGET_OWNER_OF_HEAD_ENTRY返回链表项的所有者，即TCB） */
                    /* MISRA规则兼容注释：空指针赋值相关说明，详见链接 */
                    /* coverity[misra_c_2012_rule_11_5_violation] */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
                    // 获取该任务的唤醒时间（存储在任务状态链表项xStateListItem的value字段中）
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );

                    if( xConstTickCount < xItemValue )  // 当前滴答＜任务唤醒时间（任务未超时）
                    {
                        /* 将此任务的唤醒时间设为“下一个解阻塞时间”，下次滴答直接判断此时间即可 */
                        xNextTaskUnblockTime = xItemValue;
                        break;  // 退出循环（后续任务唤醒时间更晚，无需处理）
                    }
                    else  // 任务已超时，需从阻塞态唤醒
                    {
                        mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（任务超时）
                    }

                    // 步骤1：从延迟链表中移除任务的状态链表项（解除阻塞态关联）
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );

                    // 步骤2：若任务同时在等待事件（如信号量、事件组），还需从事件链表中移除其事件链表项
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（未等待事件）
                    }

                    // 步骤3：将任务加入就绪链表（根据优先级放入对应的pxReadyTasksLists链表）
                    prvAddTaskToReadyList( pxTCB );

                    /* 若启用抢占式调度，判断是否需要触发任务切换：
                     * 仅当被唤醒任务优先级＞当前运行任务优先级时，才需要切换（同等优先级通过时间切片处理） */
                    #if ( configUSE_PREEMPTION == 1 )
                    {
                        #if ( configNUMBER_OF_CORES == 1 )  // 单核场景
                        {
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                            {
                                xSwitchRequired = pdTRUE;  // 标记需要切换
                            }
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（优先级不高）
                            }
                        }
                        #else  // 多核场景：调用prvYieldForTask判断是否需要触发对应核心的切换
                        {
                            prvYieldForTask( pxTCB );
                        }
                        #endif /* configNUMBER_OF_CORES == 1 */
                    }
                    #endif /* configUSE_PREEMPTION == 1 */
                }
            }
        }

        /* 若启用“抢占式调度+时间切片”：
         * 同等优先级的任务会按滴答间隔轮流占用CPU（时间切片），每次滴答后需检查是否需要切换到同优先级其他任务 */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            #if ( configNUMBER_OF_CORES == 1 )  // 单核场景
            {
                // 若当前优先级的就绪链表中任务数＞1（存在同优先级其他任务）
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
                {
                    xSwitchRequired = pdTRUE;  // 标记需要切换（触发时间切片）
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（无同优先级任务）
                }
            }
            #else  // 多核场景：遍历每个核心，检查是否有同优先级任务需时间切片
            {
                BaseType_t xCoreID;

                for( xCoreID = 0; xCoreID < ( ( BaseType_t ) configNUMBER_OF_CORES ); xCoreID++ )
                {
                    // 检查当前核心运行任务的优先级链表中，任务数是否＞1
                    if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCBs[ xCoreID ]->uxPriority ] ) ) > 1U )
                    {
                        xYieldRequiredForCore[ xCoreID ] = pdTRUE;  // 标记该核心需要切换
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
            }
            #endif /* configNUMBER_OF_CORES == 1 */
        }
        #endif /* ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) */

        /* 若启用滴答钩子函数（configUSE_TICK_HOOK == 1）：
         * 调用用户实现的vApplicationTickHook()，用于执行周期性任务（如系统监控、数据采样）；
         * 仅当无挂起滴答（xPendedTicks == 0）时调用，避免钩子函数在调度器不稳定状态下执行。 */
        #if ( configUSE_TICK_HOOK == 1 )
        {
            if( xPendedTicks == ( TickType_t ) 0 )
            {
                vApplicationTickHook();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_TICK_HOOK */

        /* 抢占式调度场景：汇总所有需要切换的标记，最终决定是否触发切换 */
        #if ( configUSE_PREEMPTION == 1 )
        {
            #if ( configNUMBER_OF_CORES == 1 )  // 单核场景
            {
                // 若存在挂起的切换请求（xYieldPendings[0]，如xTaskResume触发的切换）
                if( xYieldPendings[ 0 ] != pdFALSE )
                {
                    xSwitchRequired = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            #else  // 多核场景：遍历每个核心，处理切换请求
            {
                BaseType_t xCoreID, xCurrentCoreID;
                xCurrentCoreID = ( BaseType_t ) portGET_CORE_ID();  // 获取当前执行此函数的核心ID

                for( xCoreID = 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
                {
                    // 若启用“任务抢占禁用”，需先检查当前核心任务是否允许抢占
                    #if ( configUSE_TASK_PREEMPTION_DISABLE == 1 )
                        if( pxCurrentTCBs[ xCoreID ]->xPreemptionDisable == pdFALSE )
                    #endif
                    {
                        // 若该核心有“时间切片切换需求”或“挂起切换请求”
                        if( ( xYieldRequiredForCore[ xCoreID ] != pdFALSE ) || ( xYieldPendings[ xCoreID ] != pdFALSE ) )
                        {
                            if( xCoreID == xCurrentCoreID )  // 若为当前核心，标记需要切换
                            {
                                xSwitchRequired = pdTRUE;
                            }
                            else  // 若为其他核心，触发该核心的切换（prvYieldCore）
                            {
                                prvYieldCore( xCoreID );
                            }
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                }
            }
            #endif /* configNUMBER_OF_CORES == 1 */
        }
        #endif /* configUSE_PREEMPTION == 1 */
    }
    else  // 调度器已挂起：不处理任务唤醒，仅递增挂起滴答计数
    {
        xPendedTicks += 1U;  // 挂起滴答计数递增，待调度器恢复后统一处理

        /* 即使调度器挂起，滴答钩子函数仍需按固定间隔调用（用户可能依赖其周期性执行） */
        #if ( configUSE_TICK_HOOK == 1 )
        {
            vApplicationTickHook();
        }
        #endif
    }

    traceRETURN_xTaskIncrementTick( xSwitchRequired );  // 调试跟踪：函数返回，携带切换需求标记

    return xSwitchRequired;  // 返回结果：pdTRUE=需要触发任务切换，pdFALSE=无需切换
}
/*-----------------------------------------------------------*/

// 仅当启用"应用任务标签"功能时编译该函数
#if ( configUSE_APPLICATION_TASK_TAG == 1 )

    // 为任务设置"应用标签"（本质是一个钩子函数指针），用于自定义任务标识或回调关联
    // 参数1：xTask - 目标任务句柄（NULL表示当前调用任务）
    // 参数2：pxHookFunction - 要设置的标签（函数指针类型，可存储任务标识或回调逻辑）
    void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
                                     TaskHookFunction_t pxHookFunction )
    {
        TCB_t * xTCB;

        traceENTER_vTaskSetApplicationTaskTag( xTask, pxHookFunction );

        /* If xTask is NULL then it is the task hook of the calling task that is
         * getting set. */
        if( xTask == NULL )
        {
            xTCB = ( TCB_t * ) pxCurrentTCB;
        }
        else
        {
            xTCB = xTask;
        }

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        taskENTER_CRITICAL();
        {
            xTCB->pxTaskTag = pxHookFunction;
        }
        taskEXIT_CRITICAL();

        traceRETURN_vTaskSetApplicationTaskTag();
    }

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

    TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        TaskHookFunction_t xReturn;

        traceENTER_xTaskGetApplicationTaskTag( xTask );

        /* If xTask is NULL then set the calling task's hook. */
        pxTCB = prvGetTCBFromHandle( xTask );

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        taskENTER_CRITICAL();
        {
            xReturn = pxTCB->pxTaskTag;
        }
        taskEXIT_CRITICAL();

        traceRETURN_xTaskGetApplicationTaskTag( xReturn );

        return xReturn;
    }

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

    TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        TaskHookFunction_t xReturn;
        UBaseType_t uxSavedInterruptStatus;

        traceENTER_xTaskGetApplicationTaskTagFromISR( xTask );

        /* If xTask is NULL then set the calling task's hook. */
        pxTCB = prvGetTCBFromHandle( xTask );

        /* Save the hook function in the TCB.  A critical section is required as
         * the value can be accessed from an interrupt. */
        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
        {
            xReturn = pxTCB->pxTaskTag;
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_xTaskGetApplicationTaskTagFromISR( xReturn );

        return xReturn;
    }

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

    // 调用指定任务的应用钩子函数（即通过vTaskSetApplicationTaskTag设置的任务标签）
    // 参数1：xTask - 目标任务句柄（NULL表示当前调用任务）
    // 参数2：pvParameter - 传递给钩子函数的参数
    // 返回值：钩子函数的返回值（若钩子不存在则返回pdFAIL）
    BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
                                             void * pvParameter )
    {
        TCB_t * xTCB;
        BaseType_t xReturn;

        traceENTER_xTaskCallApplicationTaskHook( xTask, pvParameter );

        /* If xTask is NULL then we are calling our own task hook. */
        if( xTask == NULL )
        {
            xTCB = pxCurrentTCB;
        }
        else
        {
            xTCB = xTask;
        }

        if( xTCB->pxTaskTag != NULL )
        {
            xReturn = xTCB->pxTaskTag( pvParameter );
        }
        else
        {
            xReturn = pdFAIL;
        }

        traceRETURN_xTaskCallApplicationTaskHook( xReturn );

        return xReturn;
    }

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )
    void vTaskSwitchContext( void )
    {
        traceENTER_vTaskSwitchContext();

        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
        {
            /* 调度器当前被挂起 - 不允许上下文切换 */
            xYieldPendings[ 0 ] = pdTRUE; // 标记挂起的切换请求（单内核核心ID为0）
        }
        else
        {
            xYieldPendings[ 0 ] = pdFALSE;
            traceTASK_SWITCHED_OUT();

            #if ( configGENERATE_RUN_TIME_STATS == 1 ) // 若启用运行时间统计
            {
                #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                    // 使用替代方法获取运行时间计数器值
                    portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime[ 0 ] );
                #else
                    // 获取当前运行时间计数器值（单内核索引为0）
                    ulTotalRunTime[ 0 ] = portGET_RUN_TIME_COUNTER_VALUE();
                #endif

                /* 将当前任务的运行时间累加到其总运行时间中。
                 * 任务开始运行的时间存储在ulTaskSwitchedInTime中。
                 * 注意：此处没有溢出保护，因此计数仅在计时器溢出前有效。
                 * 对负值的检查是为了保护可疑的运行时统计计数器实现（由应用程序提供）。 */
                if( ulTotalRunTime[ 0 ] > ulTaskSwitchedInTime[ 0 ] )
                {
                    pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime[ 0 ] - ulTaskSwitchedInTime[ 0 ] );
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                ulTaskSwitchedInTime[ 0 ] = ulTotalRunTime[ 0 ];
            }
            #endif /* configGENERATE_RUN_TIME_STATS */

            /* 检查堆栈溢出（如果已配置） */
            taskCHECK_FOR_STACK_OVERFLOW();

            /* 在当前运行任务被切换出前，保存其errno值 */
            #if ( configUSE_POSIX_ERRNO == 1 )
            {
                pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
            }
            #endif

            /* 使用通用C代码或端口优化的汇编代码选择下一个要运行的任务 */
            /* MISRA参考 11.5.3 [空指针赋值] */
            /* 更多细节：https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity[misra_c_2012_rule_11_5_violation] */
            taskSELECT_HIGHEST_PRIORITY_TASK(); // 选择最高优先级的就绪任务
            traceTASK_SWITCHED_IN();

            /* 用于在切换任务后注入端口特定行为的宏，
             * 例如设置堆栈结束监视点或重新配置MPU */
            portTASK_SWITCH_HOOK( pxCurrentTCB );

            /* 新任务切换进入后，更新全局errno */
            #if ( configUSE_POSIX_ERRNO == 1 )
            {
                FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
            }
            #endif

            #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )  // 若启用C运行时TLS支持
            {
                /* 将C运行时的TLS块切换为指向该任务特定的TLS块 */
                configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
            }
            #endif
        }

        traceRETURN_vTaskSwitchContext();
    }
#else /* if ( configNUMBER_OF_CORES == 1 ) */
    void vTaskSwitchContext( BaseType_t xCoreID )
    {
        traceENTER_vTaskSwitchContext();

        /* Acquire both locks:
         * - The ISR lock protects the ready list from simultaneous access by
         *   both other ISRs and tasks.
         * - We also take the task lock to pause here in case another core has
         *   suspended the scheduler. We don't want to simply set xYieldPending
         *   and move on if another core suspended the scheduler. We should only
         *   do that if the current core has suspended the scheduler. */

        portGET_TASK_LOCK(); /* Must always acquire the task lock first. */
        portGET_ISR_LOCK();
        {
            /* vTaskSwitchContext() must never be called from within a critical section.
             * This is not necessarily true for single core FreeRTOS, but it is for this
             * SMP port. */
            configASSERT( portGET_CRITICAL_NESTING_COUNT() == 0 );

            if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
            {
                /* The scheduler is currently suspended - do not allow a context
                 * switch. */
                xYieldPendings[ xCoreID ] = pdTRUE;
            }
            else
            {
                xYieldPendings[ xCoreID ] = pdFALSE;
                traceTASK_SWITCHED_OUT();

                #if ( configGENERATE_RUN_TIME_STATS == 1 )
                {
                    #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                        portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime[ xCoreID ] );
                    #else
                        ulTotalRunTime[ xCoreID ] = portGET_RUN_TIME_COUNTER_VALUE();
                    #endif

                    /* Add the amount of time the task has been running to the
                     * accumulated time so far.  The time the task started running was
                     * stored in ulTaskSwitchedInTime.  Note that there is no overflow
                     * protection here so count values are only valid until the timer
                     * overflows.  The guard against negative values is to protect
                     * against suspect run time stat counter implementations - which
                     * are provided by the application, not the kernel. */
                    if( ulTotalRunTime[ xCoreID ] > ulTaskSwitchedInTime[ xCoreID ] )
                    {
                        pxCurrentTCBs[ xCoreID ]->ulRunTimeCounter += ( ulTotalRunTime[ xCoreID ] - ulTaskSwitchedInTime[ xCoreID ] );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ulTaskSwitchedInTime[ xCoreID ] = ulTotalRunTime[ xCoreID ];
                }
                #endif /* configGENERATE_RUN_TIME_STATS */

                /* Check for stack overflow, if configured. */
                taskCHECK_FOR_STACK_OVERFLOW();

                /* Before the currently running task is switched out, save its errno. */
                #if ( configUSE_POSIX_ERRNO == 1 )
                {
                    pxCurrentTCBs[ xCoreID ]->iTaskErrno = FreeRTOS_errno;
                }
                #endif

                /* Select a new task to run. */
                taskSELECT_HIGHEST_PRIORITY_TASK( xCoreID );
                traceTASK_SWITCHED_IN();

                /* Macro to inject port specific behaviour immediately after
                 * switching tasks, such as setting an end of stack watchpoint
                 * or reconfiguring the MPU. */
                portTASK_SWITCH_HOOK( pxCurrentTCBs[ portGET_CORE_ID() ] );

                /* After the new task is switched in, update the global errno. */
                #if ( configUSE_POSIX_ERRNO == 1 )
                {
                    FreeRTOS_errno = pxCurrentTCBs[ xCoreID ]->iTaskErrno;
                }
                #endif

                #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
                {
                    /* Switch C-Runtime's TLS Block to point to the TLS
                     * Block specific to this task. */
                    configSET_TLS_BLOCK( pxCurrentTCBs[ xCoreID ]->xTLSBlock );
                }
                #endif
            }
        }
        portRELEASE_ISR_LOCK();
        portRELEASE_TASK_LOCK();

        traceRETURN_vTaskSwitchContext();
    }
#endif /* if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

// 将当前任务放入事件链表（等待事件发生），并设置等待超时时间
void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    traceENTER_vTaskPlaceOnEventList( pxEventList, xTicksToWait );

    configASSERT( pxEventList );

    /* 调用此函数时必须满足：
     * 1. 调度器已挂起（vTaskSuspendAll()之后）
     * 2. 正在访问的队列已加锁（防止并发修改） */

    /* 将当前任务TCB的事件链表项放入指定的事件链表中。
     * 链表按优先级排序，因此最高优先级的任务会最先被事件唤醒。
     *
     * 注意：链表按ListItem_t.xItemValue的升序排列。
     * 通常，TCB的链表项xItemValue值定义为：
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * 因此，事件链表实际按优先级降序排列（高优先级任务排在前）。
     *
     * 包含事件链表的队列已加锁，防止中断同时访问。 */
    // 将当前任务的事件链表项插入事件链表（按优先级排序）
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

    // 将当前任务添加到延迟链表，设置超时时间（xTicksToWait）
    // 第二个参数pdTRUE表示：若超时，需从事件链表中移除任务
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );

    traceRETURN_vTaskPlaceOnEventList();
}
/*-----------------------------------------------------------*/

// 将当前任务放入"无序事件链表"，并指定链表项值和等待超时时间
void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    traceENTER_vTaskPlaceOnUnorderedEventList( pxEventList, xItemValue, xTicksToWait );

    configASSERT( pxEventList );

    /* 调用此函数时必须已挂起调度器。该函数由事件组（event groups）实现使用 */
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );

    /* 将项值存储到事件链表项中。
     * 此处访问事件链表项是安全的，因为中断不会访问非阻塞状态任务的事件链表项 */
    // 设置事件链表项的值，附加"正在使用"标记（避免与未使用项混淆）
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );

    /* 将TCB的事件链表项放入对应事件链表的末尾。
     * 此处访问事件链表是安全的，因为它属于事件组实现——
     * 中断不会直接访问事件组（而是通过挂起函数调用到任务级间接访问） */
    // 将任务的事件链表项插入到事件链表末尾（不按优先级排序，因此称为"无序"）
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );

    traceRETURN_vTaskPlaceOnUnorderedEventList();
}
/*-----------------------------------------------------------*/

// 仅当启用定时器功能时编译该函数
#if ( configUSE_TIMERS == 1 )

    // 将当前任务放入事件链表（受限版本），支持设置等待时间或无限等待
    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
        traceENTER_vTaskPlaceOnEventListRestricted( pxEventList, xTicksToWait, xWaitIndefinitely );

        configASSERT( pxEventList );

        /* 此函数不应由应用程序代码调用，因此名称中包含"Restricted"（受限）。
         * 它不属于公共API，专为内核代码设计，并有特殊调用要求——
         * 必须在调度器挂起的状态下调用。 */


        /* 将TCB的事件链表项放入对应的事件链表中。
         * 在这种情况下，假设只有一个任务会等待此事件链表，
         * 因此可以使用更快的listINSERT_END()函数代替vListInsert()。 */
        // 将当前任务的事件链表项插入事件链表末尾（因单任务等待，无需排序）
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );

        /* 若任务应无限期阻塞，则将阻塞时间设置为prvAddCurrentTaskToDelayedList()
         * 函数中可识别为无限延迟的值。 */
        if( xWaitIndefinitely != pdFALSE )
        {
            xTicksToWait = portMAX_DELAY;
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        // 将当前任务加入延迟链表，传入等待时间和无限等待标志
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );

        traceRETURN_vTaskPlaceOnEventListRestricted();
    }

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

// 从事件链表中移除最高优先级的任务并唤醒，返回是否需要触发上下文切换
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    TCB_t * pxUnblockedTCB;
    BaseType_t xReturn;

    traceENTER_xTaskRemoveFromEventList( pxEventList );

    /* 此函数必须在临界区中调用。也可在ISR（中断服务程序）的临界区中调用。 */

    /* 事件链表按优先级排序，因此链表头部的任务是最高优先级，可直接移除。
     * 将TCB从延迟链表中移除，并加入就绪链表。
     *
     * 若事件所属的队列已加锁，则不会调用此函数——而是修改队列的锁计数。
     * 这确保此处对事件链表的访问具有独占性。
     *
     * 此函数假设调用前已检查过pxEventList非空（避免访问空链表）。 */
    /* MISRA参考 11.5.3 [空指针赋值] */
    /* 更多细节：https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
    /* coverity[misra_c_2012_rule_11_5_violation] */
    // 获取事件链表头部任务的TCB（最高优先级等待任务）
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );

    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
        prvAddTaskToReadyList( pxUnblockedTCB );

        #if ( configUSE_TICKLESS_IDLE != 0 )  // 若启用无滴答低功耗模式
        {
            /* 若任务因内核对象（如信号量、队列）阻塞，xNextTaskUnblockTime
             * 可能被设为该任务的超时时间。若任务因非超时原因被唤醒，
             * xNextTaskUnblockTime通常无需修改（因滴答计数达到该值时会自动重置）。
             * 但启用无滴答空闲模式时，需尽早进入睡眠模式——因此此处重置xNextTaskUnblockTime，
             * 确保其尽早更新为下一个任务的唤醒时间。 */
            prvResetNextTaskUnblockTime();  // 重置下一个任务唤醒时间
        }
        #endif
    }
    else // 调度器已挂起（无法直接操作延迟/就绪链表）
    {
        /* 延迟链表和就绪链表不可访问，因此将该任务暂存到"挂起就绪链表"，
         * 待调度器恢复后再处理。 */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    }

    #if ( configNUMBER_OF_CORES == 1 )
    {
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
        {
            /* Return true if the task removed from the event list has a higher
             * priority than the calling task.  This allows the calling task to know if
             * it should force a context switch now. */
            xReturn = pdTRUE;

            /* Mark that a yield is pending in case the user is not using the
             * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
            xYieldPendings[ 0 ] = pdTRUE;
        }
        else
        {
            xReturn = pdFALSE;
        }
    }
    #else /* #if ( configNUMBER_OF_CORES == 1 ) */
    {
        xReturn = pdFALSE;

        #if ( configUSE_PREEMPTION == 1 )
        {
            prvYieldForTask( pxUnblockedTCB );

            if( xYieldPendings[ portGET_CORE_ID() ] != pdFALSE )
            {
                xReturn = pdTRUE;
            }
        }
        #endif /* #if ( configUSE_PREEMPTION == 1 ) */
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_xTaskRemoveFromEventList( xReturn );
    return xReturn;
}
/*-----------------------------------------------------------*/

// 从无序事件链表中移除指定任务链表项并唤醒任务，支持更新链表项值
void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    TCB_t * pxUnblockedTCB;

    traceENTER_vTaskRemoveFromUnorderedEventList( pxEventListItem, xItemValue );

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );

    /* 将新的链表项值存入事件链表项中。 */
    // 更新事件链表项的值（附加"正在使用"标记，避免与未使用项混淆）
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );

    /* 从事件标志（事件组）的事件链表中移除该事件链表项。中断不会直接访问事件标志。 */
    /* MISRA参考 11.5.3 [空指针赋值] */
    /* 更多细节：https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
    /* coverity[misra_c_2012_rule_11_5_violation] */
    // 通过事件链表项获取所属任务的TCB
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );

    #if ( configUSE_TICKLESS_IDLE != 0 ) // 若启用无滴答低功耗模式
    {
        /* 若任务因内核对象（如事件组）阻塞，xNextTaskUnblockTime
         * 可能被设为该任务的超时时间。若任务因非超时原因被唤醒，
         * xNextTaskUnblockTime通常无需修改（因滴答计数达到该值时会自动重置）。
         * 但启用无滴答空闲模式时，需尽早进入睡眠模式——因此此处重置xNextTaskUnblockTime，
         * 确保其尽早更新为下一个任务的唤醒时间。 */
        prvResetNextTaskUnblockTime();
    }
    #endif

    /* 将任务从延迟链表中移除，并加入就绪链表。
     * 此时调度器已挂起，因此中断不会访问就绪链表（无需额外加锁）。 */
    // 从延迟链表中移除任务的状态链表项（解除超时等待）
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    prvAddTaskToReadyList( pxUnblockedTCB );

    #if ( configNUMBER_OF_CORES == 1 )
    {
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
        {
            /* The unblocked task has a priority above that of the calling task, so
             * a context switch is required.  This function is called with the
             * scheduler suspended so xYieldPending is set so the context switch
             * occurs immediately that the scheduler is resumed (unsuspended). */
            xYieldPendings[ 0 ] = pdTRUE;
        }
    }
    #else /* #if ( configNUMBER_OF_CORES == 1 ) */
    {
        #if ( configUSE_PREEMPTION == 1 )
        {
            taskENTER_CRITICAL();
            {
                prvYieldForTask( pxUnblockedTCB );
            }
            taskEXIT_CRITICAL();
        }
        #endif
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_vTaskRemoveFromUnorderedEventList();
}
/*-----------------------------------------------------------*/

// 初始化/记录超时状态，为后续超时判断（xTaskCheckForTimeOut()）提供初始时间基准
void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    traceENTER_vTaskSetTimeOutState( pxTimeOut );

    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    {
        // 记录当前系统的滴答计数器溢出次数（用于处理xTickCount溢出场景）
        pxTimeOut->xOverflowCount = xNumOfOverflows;
        // 记录调用该函数时的系统当前滴答计数（作为超时判断的起始时间）
        pxTimeOut->xTimeOnEntering = xTickCount;
    }
    taskEXIT_CRITICAL();

    traceRETURN_vTaskSetTimeOutState();
}
/*-----------------------------------------------------------*/

// 内核内部专用的超时状态初始化函数（无临界区保护，仅用于内核代码）
void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    traceENTER_vTaskInternalSetTimeOutState( pxTimeOut );

    /* 仅内核内部使用，因为此函数不包含临界区保护 */
    // 记录当前系统的溢出计数器值
    // xNumOfOverflows：系统节拍计数器(xTickCount)溢出的次数
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    
    // 记录进入超时状态时的系统节拍值
    // xTickCount：当前系统节拍计数器的值（每过一个时钟节拍加1）
    pxTimeOut->xTimeOnEntering = xTickCount;

    traceRETURN_vTaskInternalSetTimeOutState();
}
/*-----------------------------------------------------------*/

// 检查任务等待是否超时，更新剩余等待时间，返回超时状态
// 参数1：pxTimeOut - 超时状态结构体（需先通过vTaskSetTimeOutState()初始化）
// 参数2：pxTicksToWait - 指向剩余等待时间的指针（函数会更新该值）
// 返回值：pdTRUE - 已超时；pdFALSE - 未超时
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    BaseType_t xReturn;

    traceENTER_xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    {
        /* 小优化：在临界区内，滴答计数（xTickCount）不会被中断修改，可缓存为常量 */
        const TickType_t xConstTickCount = xTickCount;
        // 计算从超时初始化到当前的已流逝时间（无符号减法，自动处理溢出）
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;

        #if ( INCLUDE_xTaskAbortDelay == 1 ) // 若启用"延迟中止"功能
            // 检查当前任务的延迟是否被主动中止（如调用xTaskAbortDelay()）
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
            {
                /* 延迟被中止，虽与超时不同，但结果一致（任务需退出等待） */
                pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE; // 清除中止标记
                xReturn = pdTRUE;  // 视为"超时"结果返回
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )  // 若启用"任务挂起"功能
            if( *pxTicksToWait == portMAX_DELAY )
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
            }
            else
        #endif

        // 场景1：处理xTickCount溢出导致的超时判断
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
        {
             /* 此时：
             * 1. 滴答计数器溢出次数已变化（xNumOfOverflows != 初始值）；
             * 2. 当前滴答计数 >= 初始滴答计数；
             * 说明xTickCount已溢出并完整循环一次，且已超过初始时间，判定为超时。 */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0; // 剩余等待时间设为0
        }
        // 场景2：未超时，更新剩余等待时间
        else if( xElapsedTime < *pxTicksToWait )
        {
            /* 已流逝时间 < 剩余等待时间，未超时 */
            *pxTicksToWait -= xElapsedTime; // 更新剩余等待时间（减去已流逝部分）
            vTaskInternalSetTimeOutState( pxTimeOut ); // 重置超时状态（为下次检查做准备）
            xReturn = pdFALSE;
        }
        // 场景3：已超时（已流逝时间 >= 剩余等待时间）
        else
        {
            *pxTicksToWait = ( TickType_t ) 0; // 剩余等待时间设为0
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();

    traceRETURN_xTaskCheckForTimeOut( xReturn );

    return xReturn;
}
/*-----------------------------------------------------------*/

// 标记当前核心存在“遗漏的切换请求”，确保后续调度时触发上下文切换
void vTaskMissedYield( void )
{
    traceENTER_vTaskMissedYield();

    /* 必须在临界区中调用。 */
    // 获取当前核心ID，将对应核心的“切换请求标记”设为pdTRUE（表示需要切换）
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;

    traceRETURN_vTaskMissedYield();
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
    {
        UBaseType_t uxReturn;
        TCB_t const * pxTCB;

        traceENTER_uxTaskGetTaskNumber( xTask );

        if( xTask != NULL )
        {
            pxTCB = xTask;
            uxReturn = pxTCB->uxTaskNumber;
        }
        else
        {
            uxReturn = 0U;
        }

        traceRETURN_uxTaskGetTaskNumber( uxReturn );

        return uxReturn;
    }

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    void vTaskSetTaskNumber( TaskHandle_t xTask,
                             const UBaseType_t uxHandle )
    {
        TCB_t * pxTCB;

        traceENTER_vTaskSetTaskNumber( xTask, uxHandle );

        if( xTask != NULL )
        {
            pxTCB = xTask;
            pxTCB->uxTaskNumber = uxHandle;
        }

        traceRETURN_vTaskSetTaskNumber();
    }

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

/*
 * -----------------------------------------------------------
 * 被动空闲任务（The passive idle task）
 * ----------------------------------------------------------
 *
 * 被动空闲任务用于SMP（对称多处理）系统中的所有额外核心（非主核心）。
 * SMP系统中必须仅存在1个主动空闲任务（active idle task），其余核心运行的均为被动空闲任务。
 *
 * portTASK_FUNCTION()宏用于支持特定端口/编译器的语言扩展。
 * 该函数对应的标准函数原型为：
 *
 * void prvPassiveIdleTask( void *pvParameters );
 */
 
#if ( configNUMBER_OF_CORES > 1 )
    static portTASK_FUNCTION( prvPassiveIdleTask, pvParameters )
    {
        ( void ) pvParameters;

        taskYIELD();

        for( ; configCONTROL_INFINITE_LOOP(); )
        {
            #if ( configUSE_PREEMPTION == 0 )
            {
                /* If we are not using preemption we keep forcing a task switch to
                 * see if any other task has become available.  If we are using
                 * preemption we don't need to do this as any task becoming available
                 * will automatically get the processor anyway. */
                taskYIELD();
            }
            #endif /* configUSE_PREEMPTION */

            #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
            {
                /* When using preemption tasks of equal priority will be
                 * timesliced.  If a task that is sharing the idle priority is ready
                 * to run then the idle task should yield before the end of the
                 * timeslice.
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains one more task than the
                 * number of idle tasks, which is equal to the configured numbers of cores
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
                {
                    taskYIELD();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */

            #if ( configUSE_PASSIVE_IDLE_HOOK == 1 )
            {
                /* Call the user defined function from within the idle task.  This
                 * allows the application designer to add background functionality
                 * without the overhead of a separate task.
                 *
                 * This hook is intended to manage core activity such as disabling cores that go idle.
                 *
                 * NOTE: vApplicationPassiveIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
                 * CALL A FUNCTION THAT MIGHT BLOCK. */
                vApplicationPassiveIdleHook();
            }
            #endif /* configUSE_PASSIVE_IDLE_HOOK */
        }
    }
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/


/*
 * -----------------------------------------------------------
 * 空闲任务（The idle task）
 * ----------------------------------------------------------
 *
 * portTASK_FUNCTION()宏用于支持特定端口/编译器的语言扩展（如中断安全属性、调用约定）。
 * 该函数对应的标准C函数原型为：
 *
 * void prvIdleTask( void *pvParameters );
 *
 */

 // 定义空闲任务函数（static修饰：仅在当前文件可见；portTASK_FUNCTION宏适配端口特性）
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    /* 消除编译器未使用参数警告 */
    ( void ) pvParameters;

    /** 这是RTOS空闲任务——调度器启动时会自动创建。**/

    /* 若某个具有安全上下文的任务自删除，空闲任务需负责删除该任务的安全上下文（如有）。
     * （注：安全上下文常见于带安全扩展的CPU，如ARM TrustZone，用于隔离安全/非安全世界资源） */
    portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );

    #if ( configNUMBER_OF_CORES > 1 )  // SMP多核心场景
    {
        /* SMP all cores start up in the idle task. This initial yield gets the application
         * tasks started. */
        taskYIELD();
    }
    #endif /* #if ( configNUMBER_OF_CORES > 1 ) */

    // 空闲任务主循环（configCONTROL_INFINITE_LOOP()是端口无关的无限循环宏，通常为for(;;)）
    for( ; configCONTROL_INFINITE_LOOP(); )
    {
         /* 检查是否有任务自删除——若有，空闲任务需负责释放被删除任务的TCB（任务控制块）和栈内存。
         * （注：任务调用vTaskDelete()后不会立即释放资源，仅标记为“待清理”，由空闲任务异步处理） */
        prvCheckTasksWaitingTermination();

        #if ( configUSE_PREEMPTION == 0 )
        {
            /* 若禁用抢占，需主动触发任务切换以检查是否有其他任务就绪。
             * 若启用抢占，就绪任务会自动抢占CPU，无需此操作。 */
            taskYIELD();
        }
        #endif /* configUSE_PREEMPTION */

        #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) // 启用抢占且空闲任务需让步
        {
            /* 启用抢占时，同优先级任务会按时间片调度。
             * 若有其他同优先级（空闲优先级）的任务就绪，空闲任务应在当前时间片结束前主动让步。
             *
             * 此处无需临界区：仅读取就绪链表长度，偶发的错误值不影响整体逻辑。
             * 若空闲优先级就绪链表的长度 > 核心数（每个核心对应1个空闲任务），
             * 说明存在非空闲任务就绪，需触发切换。 */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
            {
                taskYIELD();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */

        #if ( configUSE_IDLE_HOOK == 1 )
        {
            /* 在空闲任务中调用用户定义的钩子函数。
             * （注：钩子函数需轻量化，不可阻塞或调用可能导致阻塞的API，如vTaskDelay()） */
            vApplicationIdleHook();
        }
        #endif /* configUSE_IDLE_HOOK */

        /* 条件编译使用“!=0”而非“==1”，确保当用户自定义低功耗模式需将configUSE_TICKLESS_IDLE设为
         * 非1值时，仍能调用portSUPPRESS_TICKS_AND_SLEEP()。 */
        #if ( configUSE_TICKLESS_IDLE != 0 )
        {
            TickType_t xExpectedIdleTime;

            /* 不希望在空闲任务每次循环都挂起/恢复调度器，因此先在调度器未挂起时
             * 初步计算预计空闲时间（此结果可能因任务就绪而失效）。 */
            xExpectedIdleTime = prvGetExpectedIdleTime();

            // 若预计空闲时间 >= 进入低功耗前的最小空闲时间阈值
            if( xExpectedIdleTime >= ( TickType_t ) configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
            {
                vTaskSuspendAll();
                {
                    /* 调度器挂起后，重新采样预计空闲时间（此结果可靠，无任务干扰）。 */
                    configASSERT( xNextTaskUnblockTime >= xTickCount );
                    xExpectedIdleTime = prvGetExpectedIdleTime();

                    /* 若应用不希望调用portSUPPRESS_TICKS_AND_SLEEP()，可定义此宏将xExpectedIdleTime设为0。
                     * （用于自定义低功耗触发逻辑） */
                    configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );

                    // 再次确认预计空闲时间满足阈值
                    if( xExpectedIdleTime >= ( TickType_t ) configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
                    {
                        traceLOW_POWER_IDLE_BEGIN();
                        portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ); // 进入低功耗模式（端口实现）
                        traceLOW_POWER_IDLE_END();
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                ( void ) xTaskResumeAll();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_TICKLESS_IDLE */

        #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_PASSIVE_IDLE_HOOK == 1 ) ) // SMP且启用被动空闲钩子
        {
            /* 在空闲任务中调用用户定义的被动空闲钩子函数。
             * 允许应用在无额外任务开销的情况下添加后台功能。
             *
             * 此钩子用于管理核心活动（如禁用空闲核心以降低功耗）。
             * 注意：vApplicationPassiveIdleHook()在任何情况下都不得调用可能阻塞的函数！ */
            vApplicationPassiveIdleHook();
        }
        #endif /* #if ( ( configNUMBER_OF_CORES > 1 ) && ( configUSE_PASSIVE_IDLE_HOOK == 1 ) ) */
    }
}
/*-----------------------------------------------------------*/

// 仅当启用无滴答低功耗模式时编译该函数
#if ( configUSE_TICKLESS_IDLE != 0 )

    // 确认当前系统状态是否允许进入低功耗模式，返回低功耗状态类型
    eSleepModeStatus eTaskConfirmSleepModeStatus( void )
    {
        #if ( INCLUDE_vTaskSuspend == 1 )
            /* 系统中除应用任务外，还存在空闲任务（每个核心1个）。
             * uxNonApplicationTasks = 核心数（所有空闲任务均为非应用任务） */
            const UBaseType_t uxNonApplicationTasks = configNUMBER_OF_CORES;
        #endif /* INCLUDE_vTaskSuspend */

        eSleepModeStatus eReturn = eStandardSleep; // 默认返回“标准低功耗模式”

        traceENTER_eTaskConfirmSleepModeStatus();

        /* 此函数必须在临界区中调用。 */

        // 场景1：挂起就绪链表非空（调度器挂起时，有任务被标记为“待就绪”）
        if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0U )
        {
            /* 调度器挂起期间，已有任务变为就绪状态（需立即处理，不可进入低功耗） */
            eReturn = eAbortSleep;  // 返回“中止低功耗”
        }
        // 场景2：当前核心存在挂起的切换请求
        else if( xYieldPendings[ portGET_CORE_ID() ] != pdFALSE )
        {
            /* 调度器挂起期间，已有切换请求被挂起（需立即处理切换，不可进入低功耗） */
            eReturn = eAbortSleep;
        }
        // 场景3：存在未处理的滴答中断（xPendedTicks记录pending的滴答数）
        else if( xPendedTicks != 0U )
        {
            /* 滴答中断已触发，但因调度器挂起而被挂起（需先处理滴答，不可进入低功耗） */
            eReturn = eAbortSleep;
        }

        #if ( INCLUDE_vTaskSuspend == 1 )
            // 场景4：所有应用任务均处于挂起状态（无任务等待超时）
            else if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
            {
                /* 若所有任务都在挂起链表中（可能是无限阻塞，而非显式挂起），
                 * 则可安全关闭所有时钟，仅等待外部中断唤醒（无需关注超时） */
                eReturn = eNoTasksWaitingTimeout;
            }
        #endif /* INCLUDE_vTaskSuspend */
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_eTaskConfirmSleepModeStatus( eReturn );

        return eReturn;
    }

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

// 仅当配置了TLS指针数量（configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0）时编译该函数
#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )

    void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                            BaseType_t xIndex,
                                            void * pvValue )
    {
        TCB_t * pxTCB;

        traceENTER_vTaskSetThreadLocalStoragePointer( xTaskToSet, xIndex, pvValue );

        if( ( xIndex >= 0 ) &&
            ( xIndex < ( BaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )
        {
            pxTCB = prvGetTCBFromHandle( xTaskToSet );
            configASSERT( pxTCB != NULL );
            pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
        }

        traceRETURN_vTaskSetThreadLocalStoragePointer();
    }

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )

    void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                               BaseType_t xIndex )
    {
        void * pvReturn = NULL;
        TCB_t * pxTCB;

        traceENTER_pvTaskGetThreadLocalStoragePointer( xTaskToQuery, xIndex );

        if( ( xIndex >= 0 ) &&
            ( xIndex < ( BaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )
        {
            pxTCB = prvGetTCBFromHandle( xTaskToQuery );
            pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
        }
        else
        {
            pvReturn = NULL;
        }

        traceRETURN_pvTaskGetThreadLocalStoragePointer( pvReturn );

        return pvReturn;
    }

#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
/*-----------------------------------------------------------*/

#if ( portUSING_MPU_WRAPPERS == 1 )

    void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
                                  const MemoryRegion_t * const pxRegions )
    {
        TCB_t * pxTCB;

        traceENTER_vTaskAllocateMPURegions( xTaskToModify, pxRegions );

        /* If null is passed in here then we are modifying the MPU settings of
         * the calling task. */
        pxTCB = prvGetTCBFromHandle( xTaskToModify );

        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), pxRegions, NULL, 0 );

        traceRETURN_vTaskAllocateMPURegions();
    }

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

// 初始化FreeRTOS所有核心任务链表（就绪链表、延迟链表、挂起链表等）
static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    // 1. 初始化“就绪任务链表”：为每个优先级创建一个就绪链表
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        // 初始化当前优先级对应的就绪链表（pxReadyTasksLists是数组，每个元素对应一个优先级的就绪链表）
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    // 2. 初始化“延迟任务链表”：2个延迟链表用于处理xTickCount溢出（双缓冲机制）
    vListInitialise( &xDelayedTaskList1 );
    vListInitialise( &xDelayedTaskList2 );
    // 3. 初始化“挂起就绪链表”：临时存储调度器挂起期间被唤醒的任务
    vListInitialise( &xPendingReadyList );

    #if ( INCLUDE_vTaskDelete == 1 ) // 若启用任务删除功能
    {
        // 4. 初始化“待终止任务链表”：存储调用vTaskDelete()后待清理的任务
        vListInitialise( &xTasksWaitingTermination );
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )  // 若启用任务挂起功能
    {
        // 5. 初始化“挂起任务链表”：存储调用vTaskSuspend()显式挂起的任务
        vListInitialise( &xSuspendedTaskList );
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* 初始化延迟链表指针：
     * - pxDelayedTaskList：当前活跃的延迟链表（用于添加/查询延迟任务）
     * - pxOverflowDelayedTaskList：溢出备用延迟链表（xTickCount溢出时切换）
     * 初始状态下，活跃链表使用xDelayedTaskList1，备用链表使用xDelayedTaskList2 */
    pxDelayedTaskList = &xDelayedTaskList1;
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

// 检查并清理“待终止任务链表”中的任务（释放TCB和栈内存）
static void prvCheckTasksWaitingTermination( void )
{
     /** 此函数由RTOS空闲任务调用 **/

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp用于记录待清理任务数量，避免在空闲任务中过于频繁地进入临界区 */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                taskENTER_CRITICAL();
                {
                    {
                        /* MISRA规则11.5.3兼容处理（void指针赋值） */
                        /* 详情参考：https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                        /* coverity[misra_c_2012_rule_11_5_violation] */
                        // 从“待终止任务链表”头部获取第一个待清理任务的TCB
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
                        // 将该任务从链表中移除（xStateListItem是任务在状态链表中的节点）
                        ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                        --uxCurrentNumberOfTasks;  // 系统总任务数减1
                        --uxDeletedTasksWaitingCleanUp;  // 待清理任务数减1
                    }
                }
                taskEXIT_CRITICAL();

                prvDeleteTCB( pxTCB );  // 释放TCB和栈内存（核心清理函数）
            }
            #else /* #if( configNUMBER_OF_CORES == 1 ) */
            {
                pxTCB = NULL;

                taskENTER_CRITICAL();
                {
                    /* For SMP, multiple idles can be running simultaneously
                     * and we need to check that other idles did not cleanup while we were
                     * waiting to enter the critical section. */
                    if( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
                    {
                        /* MISRA Ref 11.5.3 [Void pointer assignment] */
                        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                        /* coverity[misra_c_2012_rule_11_5_violation] */
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );

                        if( pxTCB->xTaskRunState == taskTASK_NOT_RUNNING )
                        {
                            ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                            --uxCurrentNumberOfTasks;
                            --uxDeletedTasksWaitingCleanUp;
                        }
                        else
                        {
                            /* The TCB to be deleted still has not yet been switched out
                             * by the scheduler, so we will just exit this loop early and
                             * try again next time. */
                            taskEXIT_CRITICAL();
                            break;
                        }
                    }
                }
                taskEXIT_CRITICAL();

                if( pxTCB != NULL )
                {
                    prvDeleteTCB( pxTCB );
                }
            }
            #endif /* #if( configNUMBER_OF_CORES == 1 ) */
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    void vTaskGetInfo( TaskHandle_t xTask,
                       TaskStatus_t * pxTaskStatus,
                       BaseType_t xGetFreeStackSpace,
                       eTaskState eState )
    {
        TCB_t * pxTCB;

        traceENTER_vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );

        /* xTask is NULL then get the state of the calling task. */
        pxTCB = prvGetTCBFromHandle( xTask );

        pxTaskStatus->xHandle = pxTCB;
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
        #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
            pxTaskStatus->pxTopOfStack = ( StackType_t * ) pxTCB->pxTopOfStack;
            pxTaskStatus->pxEndOfStack = pxTCB->pxEndOfStack;
        #endif
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;

        #if ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) )
        {
            pxTaskStatus->uxCoreAffinityMask = pxTCB->uxCoreAffinityMask;
        }
        #endif

        #if ( configUSE_MUTEXES == 1 )
        {
            pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
        }
        #else
        {
            pxTaskStatus->uxBasePriority = 0;
        }
        #endif

        #if ( configGENERATE_RUN_TIME_STATS == 1 )
        {
            pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
        }
        #else
        {
            pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
        }
        #endif

        /* Obtaining the task state is a little fiddly, so is only done if the
         * value of eState passed into this function is eInvalid - otherwise the
         * state is just set to whatever is passed in. */
        if( eState != eInvalid )
        {
            if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
            {
                pxTaskStatus->eCurrentState = eRunning;
            }
            else
            {
                pxTaskStatus->eCurrentState = eState;

                #if ( INCLUDE_vTaskSuspend == 1 )
                {
                    /* If the task is in the suspended list then there is a
                     *  chance it is actually just blocked indefinitely - so really
                     *  it should be reported as being in the Blocked state. */
                    if( eState == eSuspended )
                    {
                        vTaskSuspendAll();
                        {
                            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
                            {
                                pxTaskStatus->eCurrentState = eBlocked;
                            }
                            else
                            {
                                #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                                {
                                    BaseType_t x;

                                    /* The task does not appear on the event list item of
                                     * and of the RTOS objects, but could still be in the
                                     * blocked state if it is waiting on its notification
                                     * rather than waiting on an object.  If not, is
                                     * suspended. */
                                    for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                                    {
                                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
                                        {
                                            pxTaskStatus->eCurrentState = eBlocked;
                                            break;
                                        }
                                    }
                                }
                                #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                            }
                        }
                        ( void ) xTaskResumeAll();
                    }
                }
                #endif /* INCLUDE_vTaskSuspend */

                /* Tasks can be in pending ready list and other state list at the
                 * same time. These tasks are in ready state no matter what state
                 * list the task is in. */
                taskENTER_CRITICAL();
                {
                    if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdFALSE )
                    {
                        pxTaskStatus->eCurrentState = eReady;
                    }
                }
                taskEXIT_CRITICAL();
            }
        }
        else
        {
            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
        }

        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
         * parameter is provided to allow it to be skipped. */
        if( xGetFreeStackSpace != pdFALSE )
        {
            #if ( portSTACK_GROWTH > 0 )
            {
                pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
            }
            #else
            {
                pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
            }
            #endif
        }
        else
        {
            pxTaskStatus->usStackHighWaterMark = 0;
        }

        traceRETURN_vTaskGetInfo();
    }

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                     List_t * pxList,
                                                     eTaskState eState )
    {
        UBaseType_t uxTask = 0;
        const ListItem_t * pxEndMarker = listGET_END_MARKER( pxList );
        ListItem_t * pxIterator;
        TCB_t * pxTCB = NULL;

        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
        {
            /* Populate an TaskStatus_t structure within the
             * pxTaskStatusArray array for each task that is referenced from
             * pxList.  See the definition of TaskStatus_t in task.h for the
             * meaning of each TaskStatus_t structure member. */
            for( pxIterator = listGET_HEAD_ENTRY( pxList ); pxIterator != pxEndMarker; pxIterator = listGET_NEXT( pxIterator ) )
            {
                /* MISRA Ref 11.5.3 [Void pointer assignment] */
                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                /* coverity[misra_c_2012_rule_11_5_violation] */
                pxTCB = listGET_LIST_ITEM_OWNER( pxIterator );

                vTaskGetInfo( ( TaskHandle_t ) pxTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
                uxTask++;
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return uxTask;
    }

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
        configSTACK_DEPTH_TYPE uxCount = 0U;

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
        {
            pucStackByte -= portSTACK_GROWTH;
            uxCount++;
        }

        uxCount /= ( configSTACK_DEPTH_TYPE ) sizeof( StackType_t );

        return uxCount;
    }

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )

/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
 * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
 * user to determine the return type.  It gets around the problem of the value
 * overflowing on 8-bit types without breaking backward compatibility for
 * applications that expect an 8-bit return type. */
    configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        configSTACK_DEPTH_TYPE uxReturn;

        traceENTER_uxTaskGetStackHighWaterMark2( xTask );

        /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
         * the same except for their return type.  Using configSTACK_DEPTH_TYPE
         * allows the user to determine the return type.  It gets around the
         * problem of the value overflowing on 8-bit types without breaking
         * backward compatibility for applications that expect an 8-bit return
         * type. */

        pxTCB = prvGetTCBFromHandle( xTask );

        #if portSTACK_GROWTH < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
        }
        #else
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
        }
        #endif

        uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );

        traceRETURN_uxTaskGetStackHighWaterMark2( uxReturn );

        return uxReturn;
    }

#endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        traceENTER_uxTaskGetStackHighWaterMark( xTask );

        pxTCB = prvGetTCBFromHandle( xTask );

        #if portSTACK_GROWTH < 0
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
        }
        #else
        {
            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
        }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );

        traceRETURN_uxTaskGetStackHighWaterMark( uxReturn );

        return uxReturn;
    }

#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
        /* 此调用专为TriCore处理器端口设计，必须位于vPortFree()调用之前。
         * 也适用于需要静态分配和清理RAM的端口/演示工程。 */
        portCLEAN_UP_TCB( pxTCB );  // 端口专用TCB清理（如TriCore的上下文清理）

        #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
        {
            /* Free up the memory allocated for the task's TLS Block. */
            configDEINIT_TLS_BLOCK( pxTCB->xTLSBlock );
        }
        #endif

        // 场景1：仅支持动态分配，且不使用MPU包装器
        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* 任务只能是动态分配的——需同时释放栈内存和TCB */
            vPortFreeStack( pxTCB->pxStack );
            vPortFree( pxTCB );
        }
        // 场景2：同时支持静态和动态分配（tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0）
        #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
        {
            /* 任务可能是静态分配或动态分配，因此释放前需先检查分配方式 */
            // 子场景2.1：栈和TCB均为动态分配
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
            {
                /* 栈和TCB均为动态分配，需同时释放两者 */
                vPortFreeStack( pxTCB->pxStack );
                vPortFree( pxTCB );
            }
            // 子场景2.2：仅栈为静态分配，TCB为动态分配
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
            {
                /* 仅栈是静态分配（无需释放），只需释放TCB */
                vPortFree( pxTCB );
            }
            // 子场景2.3：栈和TCB均为静态分配
            else
            {
                /* 栈和TCB均为静态分配（用户管理内存），无需释放 */
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    {
        /* 当前延迟链表为空，将xNextTaskUnblockTime设为最大可能值（portMAX_DELAY）。
         * 这样可以确保：在延迟链表添加任务前，“xTickCount >= xNextTaskUnblockTime”的判断几乎不会成立，
         * 避免误唤醒无延迟任务的情况。 */
        xNextTaskUnblockTime = portMAX_DELAY;
    }
    else
    {
        /* 当前延迟链表非空，获取链表头部任务的“链表项值”。
         * 该值即为链表头部任务的唤醒时间——头部任务是最早需要从阻塞状态唤醒的任务。 */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
/*-----------------------------------------------------------*/

// 如果启用了获取当前任务句柄功能，或者启用了互斥锁功能，或者是多核系统
#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) || ( configNUMBER_OF_CORES > 1 )

    #if ( configNUMBER_OF_CORES == 1 )
        TaskHandle_t xTaskGetCurrentTaskHandle( void )
        {
            TaskHandle_t xReturn;

            traceENTER_xTaskGetCurrentTaskHandle();

            /* A critical section is not required as this is not called from
             * an interrupt and the current TCB will always be the same for any
             * individual execution thread. */
            xReturn = pxCurrentTCB;

            traceRETURN_xTaskGetCurrentTaskHandle( xReturn );

            return xReturn;
        }
    #else /* #if ( configNUMBER_OF_CORES == 1 ) */
        TaskHandle_t xTaskGetCurrentTaskHandle( void )
        {
            TaskHandle_t xReturn;
            UBaseType_t uxSavedInterruptStatus;

            traceENTER_xTaskGetCurrentTaskHandle();

            uxSavedInterruptStatus = portSET_INTERRUPT_MASK();
            {
                xReturn = pxCurrentTCBs[ portGET_CORE_ID() ];
            }
            portCLEAR_INTERRUPT_MASK( uxSavedInterruptStatus );

            traceRETURN_xTaskGetCurrentTaskHandle( xReturn );

            return xReturn;
        }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    TaskHandle_t xTaskGetCurrentTaskHandleForCore( BaseType_t xCoreID )
    {
        TaskHandle_t xReturn = NULL;

        traceENTER_xTaskGetCurrentTaskHandleForCore( xCoreID );

        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
        {
            #if ( configNUMBER_OF_CORES == 1 )
                xReturn = pxCurrentTCB;
            #else /* #if ( configNUMBER_OF_CORES == 1 ) */
                xReturn = pxCurrentTCBs[ xCoreID ];
            #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
        }

        traceRETURN_xTaskGetCurrentTaskHandleForCore( xReturn );

        return xReturn;
    }

#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
/*-----------------------------------------------------------*/

// 如果启用了获取调度器状态功能，或者启用了定时器功能
#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
        BaseType_t xReturn;

        traceENTER_xTaskGetSchedulerState();

        if( xSchedulerRunning == pdFALSE )
        {
            xReturn = taskSCHEDULER_NOT_STARTED; // 返回"调度器未启动"状态
        }
        else
        {
            #if ( configNUMBER_OF_CORES > 1 )
                taskENTER_CRITICAL();
            #endif
            {
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
                {
                    xReturn = taskSCHEDULER_RUNNING; // 返回"调度器运行中"状态
                }
                else
                {
                    xReturn = taskSCHEDULER_SUSPENDED; // 返回"调度器已挂起"状态
                }
            }
            #if ( configNUMBER_OF_CORES > 1 )
                taskEXIT_CRITICAL();
            #endif
        }

        traceRETURN_xTaskGetSchedulerState( xReturn );

        return xReturn;
    }

#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

// 如果启用了互斥锁功能
#if ( configUSE_MUTEXES == 1 )

    // 任务优先级继承函数，参数是持有互斥锁的任务句柄
    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        traceENTER_xTaskPriorityInherit( pxMutexHolder );

        /* 如果互斥锁被中断服务程序持有，则互斥锁持有者为NULL。
         * 这种情况下不应用优先级继承。 */
        if( pxMutexHolder != NULL )
        {
            /* 如果持有互斥锁的任务优先级低于尝试获取该互斥锁的任务优先级，
             * 则持有锁的任务将临时继承尝试获取锁的任务的优先级。 */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
            {
                /* 调整持有互斥锁任务的状态以适应其新优先级。
                 * 只有当事件链表项的值未被其他用途使用时，才重置它。 */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
                {
                    // 设置事件链表项值，基于新的优先级
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority );
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                /* 如果被修改的任务处于就绪状态，需要将其移动到新的就绪链表中 */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
                    {
                        /* 已知任务在其就绪链表中，因此无需再次检查，
                         * 可以直接调用端口级别的重置宏 */
                        portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* 在将任务加入新的就绪链表前，先执行“优先级继承”：
                    * 将互斥锁持有者的任务优先级，提升到当前等待互斥锁的高优先级任务的优先级 */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
                    // 将优先级已提升的互斥锁持有者，重新加入“就绪链表”（按新优先级排序）
                    prvAddTaskToReadyList( pxMutexHolderTCB );
                    #if ( configNUMBER_OF_CORES > 1 )
                    {
                        /* The priority of the task is raised. Yield for this task
                         * if it is not running. */
                        if( taskTASK_IS_RUNNING( pxMutexHolderTCB ) != pdTRUE )
                        {
                            prvYieldForTask( pxMutexHolderTCB );
                        }
                    }
                    #endif /* if ( configNUMBER_OF_CORES > 1 ) */
                }
                else
                {
                    // 任务不在就绪链表中，只需继承优先级
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                // 标记已发生优先级继承
                xReturn = pdTRUE;
            }
            else
            {
                /* 如果持有互斥锁任务的基础优先级低于尝试获取锁的任务优先级，
                 * 但持有锁任务的当前优先级不低于尝试获取锁的任务优先级，
                 * 则说明持有锁任务已经继承了某个优先级，但如果没有的话，
                 * 本应在此处发生继承 */
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
                {
                    /* The base priority of the mutex holder is lower than the
                     * priority of the task attempting to take the mutex, but the
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_xTaskPriorityInherit( xReturn );

        return xReturn;
    }

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    // 任务优先级解除继承函数，参数是持有互斥锁的任务句柄
    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
        TCB_t * const pxTCB = pxMutexHolder;
        BaseType_t xReturn = pdFALSE;

        traceENTER_xTaskPriorityDisinherit( pxMutexHolder );

        if( pxMutexHolder != NULL )
        {
            
            /* 任务只有在持有互斥锁时才可能具有继承的优先级。
             * 如果互斥锁由任务持有，则不能从中断中释放；
             * 如果持有任务释放互斥锁，则该任务必须是当前运行的任务。 */
            configASSERT( pxTCB == pxCurrentTCB );  // 断言：持有者必须是当前运行任务
            configASSERT( pxTCB->uxMutexesHeld );  // 断言：持有者确实持有互斥锁
            ( pxTCB->uxMutexesHeld )--; // 减少持有者持有的互斥锁计数

            /* 互斥锁持有者是否继承了其他任务的优先级？ */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
            {
                /* 只有当不再持有任何互斥锁时，才解除优先级继承 */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
                {
                    /* 任务只有在持有互斥锁时才可能具有继承的优先级。
                     * 如果互斥锁由任务持有，则不能从中断中释放；
                     * 如果持有任务释放互斥锁，则该任务必须是当前运行的任务。
                     * 将持有任务从就绪链表中移除。 */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
                    {
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* 在将任务添加到新的就绪链表之前解除优先级继承 */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority; // 恢复为基础优先级

                    /* 重置事件链表项的值。如果任务正在运行，则该值不能用于其他目的，
                     * 且必须运行才能释放互斥锁。 */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
                    prvAddTaskToReadyList( pxTCB );
                    #if ( configNUMBER_OF_CORES > 1 )
                    {
                        /* The priority of the task is dropped. Yield the core on
                         * which the task is running. */
                        if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
                        {
                            prvYieldCore( pxTCB->xTaskRunState );
                        }
                    }
                    #endif /* if ( configNUMBER_OF_CORES > 1 ) */

                    /* Return true to indicate that a context switch is required.
                     * This is only actually required in the corner case whereby
                     * multiple mutexes were held and the mutexes were given back
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_xTaskPriorityDisinherit( xReturn );

        return xReturn;
    }

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    /* 超时后解除任务优先级继承的函数
     * 参数1：pxMutexHolder - 持有互斥锁的任务句柄
     * 参数2：uxHighestPriorityWaitingTask - 曾等待该互斥锁的最高优先级任务的优先级 */
    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
        TCB_t * const pxTCB = pxMutexHolder;
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        // 常量：标记“仅持有1个互斥锁”的场景
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

        traceENTER_vTaskPriorityDisinheritAfterTimeout( pxMutexHolder, uxHighestPriorityWaitingTask );

        if( pxMutexHolder != NULL )
        {
            /* 如果pxMutexHolder非NULL，说明持有者至少持有1个互斥锁
             * （断言用于调试，确保代码逻辑正确性） */
            configASSERT( pxTCB->uxMutexesHeld );

            /* 确定互斥锁持有者应设置的目标优先级：
             * 目标优先级 = 持有者的“基础优先级” 和 “曾等待该互斥锁的最高优先级” 中的较大值
             * （避免持有者优先级低于仍可能等待它的其他高优先级任务） */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
            }

            /* 检查：持有者当前优先级是否需要调整？（当前优先级≠目标优先级） */
            if( pxTCB->uxPriority != uxPriorityToUse )
            {
                /* 仅当持有者只持有当前这1个互斥锁时，才执行解除继承
                 * （逻辑简化：若持有者还持有其他互斥锁，其他锁可能已导致优先级继承，需保留高优先级） */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
                {
                    /* 若等待任务因“已持有该互斥锁”而超时（如递归锁场景），
                     * 持有者不可能继承自己的优先级（断言确保此场景不触发错误逻辑） */
                    configASSERT( pxTCB != pxCurrentTCB );

                    /* 执行优先级解除继承：记录当前优先级（用于后续判断任务状态），并设置为目标优先级 */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority; // 保存调整前的优先级
                    pxTCB->uxPriority = uxPriorityToUse;  // 应用目标优先级

                    /* 重置事件链表项的值：仅当该值未被其他用途（如等待定时器、队列）占用时才操作 */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
                    {
                        // 事件链表项值按“优先级规则”设置（值越小，优先级越高，与uxPriority反向映射）
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* 若持有者不是当前运行任务，它可能处于“就绪/阻塞/挂起”状态：
                     * 仅当持有者处于“就绪状态”时，才调整其在就绪链表中的位置
                     * （因为就绪链表按优先级分组，优先级变化需迁移链表） */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
                    {
                        // 1. 从调整前优先级对应的就绪链表中移除该任务
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
                        {
                            /* 已知任务在就绪链表中，无需重复检查，直接重置就绪优先级标记
                             * （uxTopReadyPriority记录系统最高就绪任务优先级，需同步更新） */
                            portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
                        }
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        // 2. 将任务添加到目标优先级对应的就绪链表
                        prvAddTaskToReadyList( pxTCB );
                        #if ( configNUMBER_OF_CORES > 1 )
                        {
                            /* The priority of the task is dropped. Yield the core on
                             * which the task is running. */
                            if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
                            {
                                prvYieldCore( pxTCB->xTaskRunState );
                            }
                        }
                        #endif /* if ( configNUMBER_OF_CORES > 1 ) */
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskPriorityDisinheritAfterTimeout();
    }

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

/* If not in a critical section then yield immediately.
 * Otherwise set xYieldPendings to true to wait to
 * yield until exiting the critical section.
 */
    void vTaskYieldWithinAPI( void )
    {
        traceENTER_vTaskYieldWithinAPI();

        if( portGET_CRITICAL_NESTING_COUNT() == 0U )
        {
            portYIELD();
        }
        else
        {
            xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
        }

        traceRETURN_vTaskYieldWithinAPI();
    }
#endif /* #if ( configNUMBER_OF_CORES > 1 ) */

/*-----------------------------------------------------------*/

#if ( ( portCRITICAL_NESTING_IN_TCB == 1 ) && ( configNUMBER_OF_CORES == 1 ) )

    void vTaskEnterCritical( void )
    {
        traceENTER_vTaskEnterCritical();

        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
        {
            ( pxCurrentTCB->uxCriticalNesting )++;

            /* This is not the interrupt safe version of the enter critical
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1U )
            {
                portASSERT_IF_IN_ISR();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskEnterCritical();
    }

#endif /* #if ( ( portCRITICAL_NESTING_IN_TCB == 1 ) && ( configNUMBER_OF_CORES == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

    void vTaskEnterCritical( void )
    {
        traceENTER_vTaskEnterCritical();

        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
        {
            if( portGET_CRITICAL_NESTING_COUNT() == 0U )
            {
                portGET_TASK_LOCK();
                portGET_ISR_LOCK();
            }

            portINCREMENT_CRITICAL_NESTING_COUNT();

            /* This is not the interrupt safe version of the enter critical
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( portGET_CRITICAL_NESTING_COUNT() == 1U )
            {
                portASSERT_IF_IN_ISR();

                if( uxSchedulerSuspended == 0U )
                {
                    /* The only time there would be a problem is if this is called
                     * before a context switch and vTaskExitCritical() is called
                     * after pxCurrentTCB changes. Therefore this should not be
                     * used within vTaskSwitchContext(). */
                    prvCheckForRunStateChange();
                }
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskEnterCritical();
    }

#endif /* #if ( configNUMBER_OF_CORES > 1 ) */

/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

    UBaseType_t vTaskEnterCriticalFromISR( void )
    {
        UBaseType_t uxSavedInterruptStatus = 0;

        traceENTER_vTaskEnterCriticalFromISR();

        if( xSchedulerRunning != pdFALSE )
        {
            uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();

            if( portGET_CRITICAL_NESTING_COUNT() == 0U )
            {
                portGET_ISR_LOCK();
            }

            portINCREMENT_CRITICAL_NESTING_COUNT();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskEnterCriticalFromISR( uxSavedInterruptStatus );

        return uxSavedInterruptStatus;
    }

#endif /* #if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

#if ( ( portCRITICAL_NESTING_IN_TCB == 1 ) && ( configNUMBER_OF_CORES == 1 ) )

    void vTaskExitCritical( void )
    {
        traceENTER_vTaskExitCritical();

        if( xSchedulerRunning != pdFALSE )
        {
            /* If pxCurrentTCB->uxCriticalNesting is zero then this function
             * does not match a previous call to vTaskEnterCritical(). */
            configASSERT( pxCurrentTCB->uxCriticalNesting > 0U );

            /* This function should not be called in ISR. Use vTaskExitCriticalFromISR
             * to exit critical section from ISR. */
            portASSERT_IF_IN_ISR();

            if( pxCurrentTCB->uxCriticalNesting > 0U )
            {
                ( pxCurrentTCB->uxCriticalNesting )--;

                if( pxCurrentTCB->uxCriticalNesting == 0U )
                {
                    portENABLE_INTERRUPTS();
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskExitCritical();
    }

#endif /* #if ( ( portCRITICAL_NESTING_IN_TCB == 1 ) && ( configNUMBER_OF_CORES == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

    void vTaskExitCritical( void )
    {
        traceENTER_vTaskExitCritical();

        if( xSchedulerRunning != pdFALSE )
        {
            /* If critical nesting count is zero then this function
             * does not match a previous call to vTaskEnterCritical(). */
            configASSERT( portGET_CRITICAL_NESTING_COUNT() > 0U );

            /* This function should not be called in ISR. Use vTaskExitCriticalFromISR
             * to exit critical section from ISR. */
            portASSERT_IF_IN_ISR();

            if( portGET_CRITICAL_NESTING_COUNT() > 0U )
            {
                portDECREMENT_CRITICAL_NESTING_COUNT();

                if( portGET_CRITICAL_NESTING_COUNT() == 0U )
                {
                    BaseType_t xYieldCurrentTask;

                    /* Get the xYieldPending stats inside the critical section. */
                    xYieldCurrentTask = xYieldPendings[ portGET_CORE_ID() ];

                    portRELEASE_ISR_LOCK();
                    portRELEASE_TASK_LOCK();
                    portENABLE_INTERRUPTS();

                    /* When a task yields in a critical section it just sets
                     * xYieldPending to true. So now that we have exited the
                     * critical section check if xYieldPending is true, and
                     * if so yield. */
                    if( xYieldCurrentTask != pdFALSE )
                    {
                        portYIELD();
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskExitCritical();
    }

#endif /* #if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES > 1 )

    void vTaskExitCriticalFromISR( UBaseType_t uxSavedInterruptStatus )
    {
        traceENTER_vTaskExitCriticalFromISR( uxSavedInterruptStatus );

        if( xSchedulerRunning != pdFALSE )
        {
            /* If critical nesting count is zero then this function
             * does not match a previous call to vTaskEnterCritical(). */
            configASSERT( portGET_CRITICAL_NESTING_COUNT() > 0U );

            if( portGET_CRITICAL_NESTING_COUNT() > 0U )
            {
                portDECREMENT_CRITICAL_NESTING_COUNT();

                if( portGET_CRITICAL_NESTING_COUNT() == 0U )
                {
                    portRELEASE_ISR_LOCK();
                    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskExitCriticalFromISR();
    }

#endif /* #if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

// 如果启用了任务统计信息格式化功能（configUSE_STATS_FORMATTING_FUNCTIONS > 0）
#if ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 )

    /* 静态辅助函数：将任务名称写入缓冲区，并补全空格以统一长度
     * 参数1：pcBuffer - 目标缓冲区（用于存储格式化后的任务名称）
     * 参数2：pcTaskName - 原始任务名称（待格式化的输入）
     * 返回值：指向缓冲区中任务名称末尾（'\0'后）的指针（便于后续写入其他统计信息） */
    static char * prvWriteNameToBuffer( char * pcBuffer,
                                        const char * pcTaskName )
    {
        size_t x;

        /* Start by copying the entire string. */
        ( void ) strcpy( pcBuffer, pcTaskName );

        /* Pad the end of the string with spaces to ensure columns line up when
         * printed out. */
        for( x = strlen( pcBuffer ); x < ( size_t ) ( ( size_t ) configMAX_TASK_NAME_LEN - 1U ); x++ )
        {
            pcBuffer[ x ] = ' ';
        }

        /* Terminate. */
        pcBuffer[ x ] = ( char ) 0x00;

        /* Return the new end of string. */
        return &( pcBuffer[ x ] );
    }

#endif /* ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

    void vTaskListTasks( char * pcWriteBuffer,
                         size_t uxBufferLength )
    {
        TaskStatus_t * pxTaskStatusArray;
        size_t uxConsumedBufferLength = 0;
        size_t uxCharsWrittenBySnprintf;
        int iSnprintfReturnValue;
        BaseType_t xOutputBufferFull = pdFALSE;
        UBaseType_t uxArraySize, x;
        char cStatus;

        traceENTER_vTaskListTasks( pcWriteBuffer, uxBufferLength );

        /*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskListTasks() calls uxTaskGetSystemState(), then formats part of the
         * uxTaskGetSystemState() output into a human readable table that
         * displays task: names, states, priority, stack usage and task number.
         * Stack usage specified as the number of unused StackType_t words stack can hold
         * on top of stack - not the number of bytes.
         *
         * vTaskListTasks() has a dependency on the snprintf() C library function that
         * might bloat the code size, use a lot of stack, and provide different
         * results on different platforms.  An alternative, tiny, third party,
         * and limited functionality implementation of snprintf() is provided in
         * many of the FreeRTOS/Demo sub-directories in a file called
         * printf-stdarg.c (note printf-stdarg.c does not provide a full
         * snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskListTasks().
         */


        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer = ( char ) 0x00;

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize = uxCurrentNumberOfTasks;

        /* Allocate an array index for each task.  NOTE!  if
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. */
        /* MISRA Ref 11.5.1 [Malloc memory assignment] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
        /* coverity[misra_c_2012_rule_11_5_violation] */
        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );

        if( pxTaskStatusArray != NULL )
        {
            /* Generate the (binary) data. */
            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

            /* Create a human readable table from the binary data. */
            for( x = 0; x < uxArraySize; x++ )
            {
                switch( pxTaskStatusArray[ x ].eCurrentState )
                {
                    case eRunning:
                        cStatus = tskRUNNING_CHAR;
                        break;

                    case eReady:
                        cStatus = tskREADY_CHAR;
                        break;

                    case eBlocked:
                        cStatus = tskBLOCKED_CHAR;
                        break;

                    case eSuspended:
                        cStatus = tskSUSPENDED_CHAR;
                        break;

                    case eDeleted:
                        cStatus = tskDELETED_CHAR;
                        break;

                    case eInvalid: /* Fall through. */
                    default:       /* Should not get here, but it is included
                                    * to prevent static checking errors. */
                        cStatus = ( char ) 0x00;
                        break;
                }

                /* Is there enough space in the buffer to hold task name? */
                if( ( uxConsumedBufferLength + configMAX_TASK_NAME_LEN ) <= uxBufferLength )
                {
                    /* Write the task name to the string, padding with spaces so it
                     * can be printed in tabular form more easily. */
                    pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
                    /* Do not count the terminating null character. */
                    uxConsumedBufferLength = uxConsumedBufferLength + ( configMAX_TASK_NAME_LEN - 1U );

                    /* Is there space left in the buffer? -1 is done because snprintf
                     * writes a terminating null character. So we are essentially
                     * checking if the buffer has space to write at least one non-null
                     * character. */
                    if( uxConsumedBufferLength < ( uxBufferLength - 1U ) )
                    {
                        /* Write the rest of the string. */
                        #if ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) )
                            /* MISRA Ref 21.6.1 [snprintf for utility] */
                            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */
                            /* coverity[misra_c_2012_rule_21_6_violation] */
                            iSnprintfReturnValue = snprintf( pcWriteBuffer,
                                                             uxBufferLength - uxConsumedBufferLength,
                                                             "\t%c\t%u\t%u\t%u\t0x%x\r\n",
                                                             cStatus,
                                                             ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority,
                                                             ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark,
                                                             ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber,
                                                             ( unsigned int ) pxTaskStatusArray[ x ].uxCoreAffinityMask );
                        #else /* ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) ) */
                            /* MISRA Ref 21.6.1 [snprintf for utility] */
                            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */
                            /* coverity[misra_c_2012_rule_21_6_violation] */
                            iSnprintfReturnValue = snprintf( pcWriteBuffer,
                                                             uxBufferLength - uxConsumedBufferLength,
                                                             "\t%c\t%u\t%u\t%u\r\n",
                                                             cStatus,
                                                             ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority,
                                                             ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark,
                                                             ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
                        #endif /* ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) ) */
                        uxCharsWrittenBySnprintf = prvSnprintfReturnValueToCharsWritten( iSnprintfReturnValue, uxBufferLength - uxConsumedBufferLength );

                        uxConsumedBufferLength += uxCharsWrittenBySnprintf;
                        pcWriteBuffer += uxCharsWrittenBySnprintf;
                    }
                    else
                    {
                        xOutputBufferFull = pdTRUE;
                    }
                }
                else
                {
                    xOutputBufferFull = pdTRUE;
                }

                if( xOutputBufferFull == pdTRUE )
                {
                    break;
                }
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
             * is 0 then vPortFree() will be #defined to nothing. */
            vPortFree( pxTaskStatusArray );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskListTasks();
    }

#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configUSE_TRACE_FACILITY == 1 ) )

    void vTaskGetRunTimeStatistics( char * pcWriteBuffer,
                                    size_t uxBufferLength )
    {
        TaskStatus_t * pxTaskStatusArray;
        size_t uxConsumedBufferLength = 0;
        size_t uxCharsWrittenBySnprintf;
        int iSnprintfReturnValue;
        BaseType_t xOutputBufferFull = pdFALSE;
        UBaseType_t uxArraySize, x;
        configRUN_TIME_COUNTER_TYPE ulTotalTime = 0;
        configRUN_TIME_COUNTER_TYPE ulStatsAsPercentage;

        traceENTER_vTaskGetRunTimeStatistics( pcWriteBuffer, uxBufferLength );

        /*
         * PLEASE NOTE:
         *
         * This function is provided for convenience only, and is used by many
         * of the demo applications.  Do not consider it to be part of the
         * scheduler.
         *
         * vTaskGetRunTimeStatistics() calls uxTaskGetSystemState(), then formats part
         * of the uxTaskGetSystemState() output into a human readable table that
         * displays the amount of time each task has spent in the Running state
         * in both absolute and percentage terms.
         *
         * vTaskGetRunTimeStatistics() has a dependency on the snprintf() C library
         * function that might bloat the code size, use a lot of stack, and
         * provide different results on different platforms.  An alternative,
         * tiny, third party, and limited functionality implementation of
         * snprintf() is provided in many of the FreeRTOS/Demo sub-directories in
         * a file called printf-stdarg.c (note printf-stdarg.c does not provide
         * a full snprintf() implementation!).
         *
         * It is recommended that production systems call uxTaskGetSystemState()
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskGetRunTimeStatistics().
         */

        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer = ( char ) 0x00;

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize = uxCurrentNumberOfTasks;

        /* Allocate an array index for each task.  NOTE!  If
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. */
        /* MISRA Ref 11.5.1 [Malloc memory assignment] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
        /* coverity[misra_c_2012_rule_11_5_violation] */
        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );

        if( pxTaskStatusArray != NULL )
        {
            /* Generate the (binary) data. */
            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );

            /* For percentage calculations. */
            ulTotalTime /= ( ( configRUN_TIME_COUNTER_TYPE ) 100U );

            /* Avoid divide by zero errors. */
            if( ulTotalTime > 0U )
            {
                /* Create a human readable table from the binary data. */
                for( x = 0; x < uxArraySize; x++ )
                {
                    /* What percentage of the total run time has the task used?
                     * This will always be rounded down to the nearest integer.
                     * ulTotalRunTime has already been divided by 100. */
                    ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;

                    /* Is there enough space in the buffer to hold task name? */
                    if( ( uxConsumedBufferLength + configMAX_TASK_NAME_LEN ) <= uxBufferLength )
                    {
                        /* Write the task name to the string, padding with
                         * spaces so it can be printed in tabular form more
                         * easily. */
                        pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
                        /* Do not count the terminating null character. */
                        uxConsumedBufferLength = uxConsumedBufferLength + ( configMAX_TASK_NAME_LEN - 1U );

                        /* Is there space left in the buffer? -1 is done because snprintf
                         * writes a terminating null character. So we are essentially
                         * checking if the buffer has space to write at least one non-null
                         * character. */
                        if( uxConsumedBufferLength < ( uxBufferLength - 1U ) )
                        {
                            if( ulStatsAsPercentage > 0U )
                            {
                                #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                                {
                                    /* MISRA Ref 21.6.1 [snprintf for utility] */
                                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */
                                    /* coverity[misra_c_2012_rule_21_6_violation] */
                                    iSnprintfReturnValue = snprintf( pcWriteBuffer,
                                                                     uxBufferLength - uxConsumedBufferLength,
                                                                     "\t%lu\t\t%lu%%\r\n",
                                                                     pxTaskStatusArray[ x ].ulRunTimeCounter,
                                                                     ulStatsAsPercentage );
                                }
                                #else /* ifdef portLU_PRINTF_SPECIFIER_REQUIRED */
                                {
                                    /* sizeof( int ) == sizeof( long ) so a smaller
                                     * printf() library can be used. */
                                    /* MISRA Ref 21.6.1 [snprintf for utility] */
                                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */
                                    /* coverity[misra_c_2012_rule_21_6_violation] */
                                    iSnprintfReturnValue = snprintf( pcWriteBuffer,
                                                                     uxBufferLength - uxConsumedBufferLength,
                                                                     "\t%u\t\t%u%%\r\n",
                                                                     ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter,
                                                                     ( unsigned int ) ulStatsAsPercentage );
                                }
                                #endif /* ifdef portLU_PRINTF_SPECIFIER_REQUIRED */
                            }
                            else
                            {
                                /* If the percentage is zero here then the task has
                                 * consumed less than 1% of the total run time. */
                                #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
                                {
                                    /* MISRA Ref 21.6.1 [snprintf for utility] */
                                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */
                                    /* coverity[misra_c_2012_rule_21_6_violation] */
                                    iSnprintfReturnValue = snprintf( pcWriteBuffer,
                                                                     uxBufferLength - uxConsumedBufferLength,
                                                                     "\t%lu\t\t<1%%\r\n",
                                                                     pxTaskStatusArray[ x ].ulRunTimeCounter );
                                }
                                #else
                                {
                                    /* sizeof( int ) == sizeof( long ) so a smaller
                                     * printf() library can be used. */
                                    /* MISRA Ref 21.6.1 [snprintf for utility] */
                                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */
                                    /* coverity[misra_c_2012_rule_21_6_violation] */
                                    iSnprintfReturnValue = snprintf( pcWriteBuffer,
                                                                     uxBufferLength - uxConsumedBufferLength,
                                                                     "\t%u\t\t<1%%\r\n",
                                                                     ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
                                }
                                #endif /* ifdef portLU_PRINTF_SPECIFIER_REQUIRED */
                            }

                            uxCharsWrittenBySnprintf = prvSnprintfReturnValueToCharsWritten( iSnprintfReturnValue, uxBufferLength - uxConsumedBufferLength );
                            uxConsumedBufferLength += uxCharsWrittenBySnprintf;
                            pcWriteBuffer += uxCharsWrittenBySnprintf;
                        }
                        else
                        {
                            xOutputBufferFull = pdTRUE;
                        }
                    }
                    else
                    {
                        xOutputBufferFull = pdTRUE;
                    }

                    if( xOutputBufferFull == pdTRUE )
                    {
                        break;
                    }
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
             * is 0 then vPortFree() will be #defined to nothing. */
            vPortFree( pxTaskStatusArray );
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskGetRunTimeStatistics();
    }

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

/* 重置当前任务事件链表项值的函数
 * 返回值：重置前的事件链表项原始值（用于后续判断或恢复） */
TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    traceENTER_uxTaskResetEventItemValue();

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );

    /* 第二步：将事件链表项重置为默认值——使其能正常用于队列和信号量操作
     * 默认值计算规则：(最大优先级 - 当前任务优先级)
     * 该规则确保链表项值与任务优先级反向关联（优先级越高，值越小），
     * 符合FreeRTOS链表按值升序排序的特性（值越小越先被调度） */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );

    traceRETURN_uxTaskResetEventItemValue( uxReturn );

    return uxReturn;
}
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        TCB_t * pxTCB;

        traceENTER_pvTaskIncrementMutexHeldCount();

        pxTCB = pxCurrentTCB;

        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxTCB != NULL )
        {
            ( pxTCB->uxMutexesHeld )++;
        }

        traceRETURN_pvTaskIncrementMutexHeldCount( pxTCB );

        return pxTCB;
    }

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

// 如果启用了任务通知功能（configUSE_TASK_NOTIFICATIONS == 1）
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    /* 通用任务通知获取函数（支持指定索引、计数处理、超时等待）
     * 参数1：uxIndexToWaitOn - 要等待的任务通知索引（0~configTASK_NOTIFICATION_ARRAY_ENTRIES-1）
     * 参数2：xClearCountOnExit - 获取后是否清空通知计数（pdTRUE=清空，pdFALSE=递减1）
     * 参数3：xTicksToWait - 超时等待时间（单位：系统节拍，0=不等待，portMAX_DELAY=永久等待）
     * 返回值：获取到的通知计数值（超时返回0） */
    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
        uint32_t ulReturn;
        BaseType_t xAlreadyYielded, xShouldBlock = pdFALSE;

        traceENTER_ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );

        // 断言：确保等待的通知索引在合法范围内（不超过配置的最大通知数）
        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* 此处挂起调度器：因为prvAddCurrentTaskToDelayedList（添加任务到延迟链表）
         * 是“非确定性操作”（执行时间不固定），挂起调度器可避免并发冲突 */
        vTaskSuspendAll();
        {
            /* 必须进入临界区：原子性完成“检查通知是否已到达”和“标记等待状态”
             * 若不原子操作，可能导致中断发送的通知丢失（检查后、标记前收到通知） */
            taskENTER_CRITICAL();
            {
                /* 仅当目标索引的通知计数为0时，才需要阻塞等待
                 * （若计数已非0，直接获取，无需等待） */
                if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
                {
                    // 标记当前任务为“等待该索引通知”的状态
                    pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;

                    // 若超时时间大于0，设置“需要阻塞”标志
                    if( xTicksToWait > ( TickType_t ) 0 )
                    {
                        xShouldBlock = pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();

            /* We are now out of the critical section but the scheduler is still
             * suspended, so we are safe to do non-deterministic operations such
             * as prvAddCurrentTaskToDelayedList. */
            if( xShouldBlock == pdTRUE )
            {
                traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWaitOn );
                prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();

        /* 若任务需要阻塞，且调度器恢复时未触发切换：
         * 手动触发一次任务切换（确保高优先级任务能抢占当前任务） */
        if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
        {
            taskYIELD_WITHIN_API();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWaitOn );
            // 读取当前通知计数值（作为返回值基础）
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];

            // 若获取到的计数值非0，按配置处理计数
            if( ulReturn != 0U )
            {
                if( xClearCountOnExit != pdFALSE )
                {
                    // 配置为“清空”：将通知计数设为0
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
                }
                else
                {
                    // 配置为“递减”：将通知计数减1（适用于“消费型”通知）
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            // 重置任务状态：标记为“不再等待该索引通知”
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
        }
        taskEXIT_CRITICAL();

        traceRETURN_ulTaskGenericNotifyTake( ulReturn );

        return ulReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

// 如果启用了任务通知功能（configUSE_TASK_NOTIFICATIONS == 1）
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    /* 通用任务通知等待函数（支持按位清、指定索引、超时等待）
     * 参数1：uxIndexToWaitOn - 要等待的任务通知索引（0~configTASK_NOTIFICATION_ARRAY_ENTRIES-1）
     * 参数2：ulBitsToClearOnEntry - 进入函数时要清除的通知值位（按位与取反操作，0=不清除）
     * 参数3：ulBitsToClearOnExit - 成功获取通知后要清除的通知值位（0=不清除）
     * 参数4：pulNotificationValue - 输出参数：用于存储获取到的通知值（NULL=不输出）
     * 参数5：xTicksToWait - 超时等待时间（单位：系统节拍，0=不等待，portMAX_DELAY=永久等待）
     * 返回值：pdTRUE=成功获取通知，pdFALSE=超时未获取到通知 */
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
        BaseType_t xReturn, xAlreadyYielded, xShouldBlock = pdFALSE;

        traceENTER_xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );

        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* We suspend the scheduler here as prvAddCurrentTaskToDelayedList is a
         * non-deterministic operation. */
        vTaskSuspendAll();
        {
            /* We MUST enter a critical section to atomically check and update the
             * task notification value. If we do not do so, a notification from
             * an ISR will get lost. */
            taskENTER_CRITICAL();
            {
                /* 仅当“无通知已到达”时，才需要阻塞等待
                 * ucNotifyState为taskNOTIFICATION_RECEIVED表示通知已到达（无需等待） */
                if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
                {
                    /* 进入函数时清除通知值的指定位：
                     * 逻辑为“通知值 & ~要清除的位”，仅保留非清除位的值
                     * 用途：例如清除历史遗留的无效位，确保等待的是新通知 */
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;

                    // 标记当前任务为“等待该索引通知”的状态
                    pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;

                    // 若超时时间大于0，设置“需要阻塞”标志
                    if( xTicksToWait > ( TickType_t ) 0 )
                    {
                        xShouldBlock = pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();

            /* We are now out of the critical section but the scheduler is still
             * suspended, so we are safe to do non-deterministic operations such
             * as prvAddCurrentTaskToDelayedList. */
            if( xShouldBlock == pdTRUE )
            {
                traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWaitOn );
                prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();

        /* Force a reschedule if xTaskResumeAll has not already done so. */
        if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
        {
            taskYIELD_WITHIN_API();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWaitOn );

            // 若输出参数非NULL，将当前通知值写入输出指针（供调用者获取）
            if( pulNotificationValue != NULL )
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
            }

            /* 判断是否获取到通知：
             * - 若状态≠taskNOTIFICATION_RECEIVED：未收到通知（超时）
             * - 若状态==taskNOTIFICATION_RECEIVED：收到通知（或通知已提前到达） */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
            }
            else
            {
                // 收到通知：清除通知值的指定位（按ulBitsToClearOnExit配置）
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
        }
        taskEXIT_CRITICAL();

        traceRETURN_xTaskGenericNotifyWait( xReturn );

        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

// 如果启用了任务通知功能（configUSE_TASK_NOTIFICATIONS == 1），则编译此函数
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    /* 通用任务通知发送函数（支持指定接收任务、通知索引、更新动作及返回发送前的通知值）
     * 参数说明：
     *   xTaskToNotify：接收通知的目标任务句柄（必须非NULL，否则触发断言）
     *   uxIndexToNotify：要操作的通知索引（范围：0 ~ configTASK_NOTIFICATION_ARRAY_ENTRIES-1，支持多通知）
     *   ulValue：通知数据值（含义随eAction变化，可能是位掩码、计数值或具体数值）
     *   eAction：通知更新动作（枚举类型，定义如何修改接收任务的通知值）
     *   pulPreviousNotificationValue：输出参数（可选），存储“发送通知前接收任务的旧通知值”（传NULL则不输出）
     * 返回值：pdPASS=通知发送/处理成功；pdFAIL=仅在特定动作（如eSetValueWithoutOverwrite）下失败（通知未更新）
     */
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
        TCB_t * pxTCB;  // 指向接收通知任务的任务控制块（TCB）
        BaseType_t xReturn = pdPASS;  // 函数返回结果，默认设为“成功”
        uint8_t ucOriginalNotifyState;  // 存储接收任务“发送通知前的通知状态”

        // 调试跟踪：记录函数入口，携带输入参数信息
        traceENTER_xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );

        // 断言检查1：通知索引必须在合法范围内（不超过系统支持的最大通知数）
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        // 断言检查2：接收任务句柄不能为NULL（必须指定有效任务）
        configASSERT( xTaskToNotify );
        // 通过任务句柄获取对应的TCB指针（任务句柄本质是TCB指针的封装）
        pxTCB = xTaskToNotify;

        // 进入临界区：确保通知处理过程中不被其他任务/中断打断（保证原子性）
        taskENTER_CRITICAL();
        {
            // 若需要输出“发送前的旧通知值”（pulPreviousNotificationValue非NULL）
            if( pulPreviousNotificationValue != NULL )
            {
                // 从TCB的通知值数组中，读取指定索引的旧值并存入输出参数
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
            }

            // 保存接收任务“发送通知前的通知状态”（如“等待通知”“已接收通知”等）
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];

            // 将接收任务的通知状态更新为“已接收通知”（taskNOTIFICATION_RECEIVED）
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;

            // 根据“通知动作（eAction）”，执行不同的通知值更新逻辑
            switch( eAction )
            {
                // 动作1：按位或（将ulValue的位掩码叠加到现有通知值上）
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
                    break;

                // 动作2：自增（将现有通知值加1，ulValue参数无效）
                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
                    break;

                // 动作3：覆盖写入（用ulValue直接覆盖现有通知值，无论旧值如何）
                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                // 动作4：不覆盖写入（仅当旧通知值未被处理时，才用ulValue更新；若已存在未处理通知，则不更新并返回失败）
                case eSetValueWithoutOverwrite:
                    // 检查“发送前的通知状态”：若不是“已接收通知”（即旧通知已被处理），才允许更新
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    }
                    else
                    {
                        /* 旧通知未被处理，无法覆盖，标记返回失败 */
                        xReturn = pdFAIL;
                    }
                    break;

                // 动作5：无数据更新（仅触发通知事件，不修改通知值）
                case eNoAction:
                    /* 任务仅被通知，但通知值保持不变（用于“纯事件触发”场景） */
                    break;

                // 默认分支：若传入无效的eAction，触发断言（确保枚举值合法）
                default:
                    /* 若所有枚举值都已处理，理论上不会进入此分支；
                     * 通过“判断xTickCount是否为0”强制触发断言（xTickCount是全局变量，编译器无法假设其值为0） */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
            }

            // 调试跟踪：记录当前操作的通知索引
            traceTASK_NOTIFY( uxIndexToNotify );

            /* 关键逻辑：若接收任务在“发送通知前”正处于“等待通知”状态（ucOriginalNotifyState == taskWAITING_NOTIFICATION），
             * 则将其从阻塞链表中移除，加入就绪链表，使其能立即处理新通知 */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
            {
                // 从阻塞链表中移除任务的状态链表项（解除阻塞状态）
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                // 将任务加入就绪链表（根据优先级放入对应的就绪链表）
                prvAddTaskToReadyList( pxTCB );

                // 断言检查：等待通知的任务不应关联任何事件链表（事件等待由其他API处理，与通知无关）
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                // 若启用低功耗Tickless模式（configUSE_TICKLESS_IDLE != 0）
                #if ( configUSE_TICKLESS_IDLE != 0 )
                {
                    /* 注释说明：
                     * 若任务因等待通知而阻塞，xNextTaskUnblockTime可能被设为该任务的超时时间；
                     * 若任务因“收到通知”而非“超时”被唤醒，xNextTaskUnblockTime通常无需修改（Tick到达超时时间时会自动重置）；
                     * 但Tickless模式下，为尽早进入低功耗睡眠，需手动重置xNextTaskUnblockTime，确保系统能计算正确的下一个唤醒时间。 */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                /* 检查：若被唤醒的任务优先级高于当前运行任务（抢占式调度下），触发任务切换，让高优先级任务立即执行 */
                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();  // 覆盖率测试标记（接收任务未等待通知时执行）
            }
        }
        // 退出临界区：恢复中断/任务调度权限
        taskEXIT_CRITICAL();

        // 调试跟踪：记录函数返回，携带返回结果
        traceRETURN_xTaskGenericNotify( xReturn );

        // 返回最终结果（pdPASS或pdFAIL）
        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
        UBaseType_t uxSavedInterruptStatus;

        traceENTER_xTaskGenericNotifyFromISR( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken );

        configASSERT( xTaskToNotify );
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
         * failure if a FreeRTOS API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;

                case eNoAction:

                    /* The task is being notified without its notify value being
                     * updated. */
                    break;

                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
            }

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
                }

                #if ( configNUMBER_OF_CORES == 1 )
                {
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                    {
                        /* The notified task has a priority above the currently
                         * executing task so a yield is required. */
                        if( pxHigherPriorityTaskWoken != NULL )
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
                        }

                        /* Mark that a yield is pending in case the user is not
                         * using the "xHigherPriorityTaskWoken" parameter to an ISR
                         * safe FreeRTOS function. */
                        xYieldPendings[ 0 ] = pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #else /* #if ( configNUMBER_OF_CORES == 1 ) */
                {
                    #if ( configUSE_PREEMPTION == 1 )
                    {
                        prvYieldForTask( pxTCB );

                        if( xYieldPendings[ portGET_CORE_ID() ] == pdTRUE )
                        {
                            if( pxHigherPriorityTaskWoken != NULL )
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
                            }
                        }
                    }
                    #endif /* if ( configUSE_PREEMPTION == 1 ) */
                }
                #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
            }
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_xTaskGenericNotifyFromISR( xReturn );

        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        UBaseType_t uxSavedInterruptStatus;

        traceENTER_vTaskGenericNotifyGiveFromISR( xTaskToNotify, uxIndexToNotify, pxHigherPriorityTaskWoken );

        configASSERT( xTaskToNotify );
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* RTOS ports that support interrupt nesting have the concept of a
         * maximum  system call (or maximum API call) interrupt priority.
         * Interrupts that are  above the maximum system call priority are keep
         * permanently enabled, even when the RTOS kernel is in a critical section,
         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
         * is defined in FreeRTOSConfig.h then
         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
         * failure if a FreeRTOS API function is called from an interrupt that has
         * been assigned a priority above the configured maximum system call
         * priority.  Only FreeRTOS functions that end in FromISR can be called
         * from interrupts  that have been assigned a priority at or (logically)
         * below the maximum system call interrupt priority.  FreeRTOS maintains a
         * separate interrupt safe API to ensure interrupt entry is as fast and as
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
                }

                #if ( configNUMBER_OF_CORES == 1 )
                {
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
                    {
                        /* The notified task has a priority above the currently
                         * executing task so a yield is required. */
                        if( pxHigherPriorityTaskWoken != NULL )
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
                        }

                        /* Mark that a yield is pending in case the user is not
                         * using the "xHigherPriorityTaskWoken" parameter in an ISR
                         * safe FreeRTOS function. */
                        xYieldPendings[ 0 ] = pdTRUE;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #else /* #if ( configNUMBER_OF_CORES == 1 ) */
                {
                    #if ( configUSE_PREEMPTION == 1 )
                    {
                        prvYieldForTask( pxTCB );

                        if( xYieldPendings[ portGET_CORE_ID() ] == pdTRUE )
                        {
                            if( pxHigherPriorityTaskWoken != NULL )
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
                            }
                        }
                    }
                    #endif /* #if ( configUSE_PREEMPTION == 1 ) */
                }
                #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
            }
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_vTaskGenericNotifyGiveFromISR();
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
        TCB_t * pxTCB;
        BaseType_t xReturn;

        traceENTER_xTaskGenericNotifyStateClear( xTask, uxIndexToClear );

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );

        taskENTER_CRITICAL();
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
                xReturn = pdPASS;
            }
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();

        traceRETURN_xTaskGenericNotifyStateClear( xReturn );

        return xReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
        TCB_t * pxTCB;
        uint32_t ulReturn;

        traceENTER_ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );

        taskENTER_CRITICAL();
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
        }
        taskEXIT_CRITICAL();

        traceRETURN_ulTaskGenericNotifyValueClear( ulReturn );

        return ulReturn;
    }

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

    configRUN_TIME_COUNTER_TYPE ulTaskGetRunTimeCounter( const TaskHandle_t xTask )
    {
        TCB_t * pxTCB;

        traceENTER_ulTaskGetRunTimeCounter( xTask );

        pxTCB = prvGetTCBFromHandle( xTask );

        traceRETURN_ulTaskGetRunTimeCounter( pxTCB->ulRunTimeCounter );

        return pxTCB->ulRunTimeCounter;
    }

#endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
/*-----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

    configRUN_TIME_COUNTER_TYPE ulTaskGetRunTimePercent( const TaskHandle_t xTask )
    {
        TCB_t * pxTCB;
        configRUN_TIME_COUNTER_TYPE ulTotalTime, ulReturn;

        traceENTER_ulTaskGetRunTimePercent( xTask );

        ulTotalTime = ( configRUN_TIME_COUNTER_TYPE ) portGET_RUN_TIME_COUNTER_VALUE();

        /* For percentage calculations. */
        ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;

        /* Avoid divide by zero errors. */
        if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )
        {
            pxTCB = prvGetTCBFromHandle( xTask );
            ulReturn = pxTCB->ulRunTimeCounter / ulTotalTime;
        }
        else
        {
            ulReturn = 0;
        }

        traceRETURN_ulTaskGetRunTimePercent( ulReturn );

        return ulReturn;
    }

#endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
/*-----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )

    configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void )
    {
        configRUN_TIME_COUNTER_TYPE ulReturn = 0;
        BaseType_t i;

        traceENTER_ulTaskGetIdleRunTimeCounter();

        for( i = 0; i < ( BaseType_t ) configNUMBER_OF_CORES; i++ )
        {
            ulReturn += xIdleTaskHandles[ i ]->ulRunTimeCounter;
        }

        traceRETURN_ulTaskGetIdleRunTimeCounter( ulReturn );

        return ulReturn;
    }

#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )

    configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void )
    {
        configRUN_TIME_COUNTER_TYPE ulTotalTime, ulReturn;
        configRUN_TIME_COUNTER_TYPE ulRunTimeCounter = 0;
        BaseType_t i;

        traceENTER_ulTaskGetIdleRunTimePercent();

        ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE() * configNUMBER_OF_CORES;

        /* For percentage calculations. */
        ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;

        /* Avoid divide by zero errors. */
        if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )
        {
            for( i = 0; i < ( BaseType_t ) configNUMBER_OF_CORES; i++ )
            {
                ulRunTimeCounter += xIdleTaskHandles[ i ]->ulRunTimeCounter;
            }

            ulReturn = ulRunTimeCounter / ulTotalTime;
        }
        else
        {
            ulReturn = 0;
        }

        traceRETURN_ulTaskGetIdleRunTimePercent( ulReturn );

        return ulReturn;
    }

#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

/* 静态函数：将当前任务添加到延迟链表或挂起链表
 * 参数1：xTicksToWait - 任务阻塞的超时时间（单位：系统节拍，portMAX_DELAY=永久阻塞）
 * 参数2：xCanBlockIndefinitely - 是否允许永久阻塞（pdTRUE=允许，pdFALSE=仅允许超时阻塞）
 * 功能：根据阻塞类型和节拍溢出状态，将任务从就绪链表移至对应阻塞链表，实现超时等待 */
static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    List_t * const pxDelayedList = pxDelayedTaskList;
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;

    // 若启用了“中止延迟”功能（INCLUDE_xTaskAbortDelay == 1）
    #if ( INCLUDE_xTaskAbortDelay == 1 )
    {
         /* 任务即将进入延迟链表，需将“延迟中止标志”重置为pdFALSE
         * 这样当任务从阻塞状态退出时，可通过该标志判断是否是被中止延迟唤醒 */
        pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
    }
    #endif

    /* 第一步：先将任务从就绪链表中移除
     * 原因：任务的xStateListItem链表项既用于就绪链表，也用于阻塞链表，不能同时存在于两个链表 */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    {
        /* 若返回值为0，说明任务原本在就绪链表中（就绪链表移除成功）
         * 此时需重置“就绪优先级标记”（uxTopReadyPriority记录系统最高就绪优先级） */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        /* 判断是否满足“永久阻塞”条件：
         * 1. 超时时间为portMAX_DELAY（表示永久阻塞）；
         * 2. 允许永久阻塞（xCanBlockIndefinitely == pdTRUE） */
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
        {
            /* 满足永久阻塞条件：将任务添加到“挂起任务链表”
             * 挂起链表中的任务不会被超时唤醒，只能通过vTaskResume()等函数手动唤醒 */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
        }
        else
        {
            /* 不满足永久阻塞条件：按超时阻塞处理，计算任务唤醒时间 */
            xTimeToWake = xConstTickCount + xTicksToWait;

            /* 设置任务链表项的值为“唤醒时间”
             * 延迟链表按“唤醒时间升序”排序，确保最早唤醒的任务排在链表头部，便于调度器快速查找 */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

            /* 判断唤醒时间是否溢出：
             * 若xTimeToWake < xConstTickCount，说明系统节拍计数溢出（如uint32_t从0xFFFFFFFF加1变为0） */
            if( xTimeToWake < xConstTickCount )
            {
                /* 唤醒时间溢出：将任务添加到“延迟溢出链表”
                 * 溢出链表专门处理节拍溢出后的超时任务，避免与未溢出任务的唤醒逻辑冲突 */
                traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
            }
            else
            {
                /* 唤醒时间未溢出：将任务添加到“正常延迟链表” */
                traceMOVED_TASK_TO_DELAYED_LIST();
                vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );

                /* 若当前任务的唤醒时间早于“下一个任务唤醒时间”（xNextTaskUnblockTime）：
                 * 更新xNextTaskUnblockTime为当前任务的唤醒时间
                 * 目的：调度器可通过xNextTaskUnblockTime快速确定下一次需要唤醒任务的时间，减少轮询开销 */
                if( xTimeToWake < xNextTaskUnblockTime )
                {
                    xNextTaskUnblockTime = xTimeToWake;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
    }
    #else /* INCLUDE_vTaskSuspend */
    {
        /* 未启用挂起功能，只能按超时阻塞处理，计算唤醒时间 */
        xTimeToWake = xConstTickCount + xTicksToWait;

        /* 设置链表项值为唤醒时间，用于延迟链表排序 */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

        /* 判断唤醒时间是否溢出，分发到对应延迟链表 */
        if( xTimeToWake < xConstTickCount )
        {
            traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
        }
        else
        {
            traceMOVED_TASK_TO_DELAYED_LIST();
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
            {
                xNextTaskUnblockTime = xTimeToWake;
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
/*-----------------------------------------------------------*/

#if ( portUSING_MPU_WRAPPERS == 1 )

    xMPU_SETTINGS * xTaskGetMPUSettings( TaskHandle_t xTask )
    {
        TCB_t * pxTCB;

        traceENTER_xTaskGetMPUSettings( xTask );

        pxTCB = prvGetTCBFromHandle( xTask );

        traceRETURN_xTaskGetMPUSettings( &( pxTCB->xMPUSettings ) );

        return &( pxTCB->xMPUSettings );
    }

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

/* 以下代码允许在本源文件中插入额外代码，
 * 尤其适用于需要访问文件作用域内函数和数据的场景（例如，执行模块测试时）。 */

#ifdef FREERTOS_MODULE_TEST
    #include "tasks_test_access_functions.h"
#endif


#if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )

    #include "freertos_tasks_c_additions.h"

    #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
        static void freertos_tasks_c_additions_init( void )
        {
            FREERTOS_TASKS_C_ADDITIONS_INIT();
        }
    #endif

#endif /* if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 ) */
/*-----------------------------------------------------------*/

#if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configKERNEL_PROVIDED_STATIC_MEMORY == 1 ) && ( portUSING_MPU_WRAPPERS == 0 ) )

/*
 * This is the kernel provided implementation of vApplicationGetIdleTaskMemory()
 * to provide the memory that is used by the Idle task. It is used when
 * configKERNEL_PROVIDED_STATIC_MEMORY is set to 1. The application can provide
 * it's own implementation of vApplicationGetIdleTaskMemory by setting
 * configKERNEL_PROVIDED_STATIC_MEMORY to 0 or leaving it undefined.
 */
    void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer,
                                        StackType_t ** ppxIdleTaskStackBuffer,
                                        configSTACK_DEPTH_TYPE * puxIdleTaskStackSize )
    {
        static StaticTask_t xIdleTaskTCB;
        static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

        *ppxIdleTaskTCBBuffer = &( xIdleTaskTCB );
        *ppxIdleTaskStackBuffer = &( uxIdleTaskStack[ 0 ] );
        *puxIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    }

    #if ( configNUMBER_OF_CORES > 1 )

        void vApplicationGetPassiveIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer,
                                                   StackType_t ** ppxIdleTaskStackBuffer,
                                                   configSTACK_DEPTH_TYPE * puxIdleTaskStackSize,
                                                   BaseType_t xPassiveIdleTaskIndex )
        {
            static StaticTask_t xIdleTaskTCBs[ configNUMBER_OF_CORES - 1 ];
            static StackType_t uxIdleTaskStacks[ configNUMBER_OF_CORES - 1 ][ configMINIMAL_STACK_SIZE ];

            *ppxIdleTaskTCBBuffer = &( xIdleTaskTCBs[ xPassiveIdleTaskIndex ] );
            *ppxIdleTaskStackBuffer = &( uxIdleTaskStacks[ xPassiveIdleTaskIndex ][ 0 ] );
            *puxIdleTaskStackSize = configMINIMAL_STACK_SIZE;
        }

    #endif /* #if ( configNUMBER_OF_CORES > 1 ) */

#endif /* #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configKERNEL_PROVIDED_STATIC_MEMORY == 1 ) && ( portUSING_MPU_WRAPPERS == 0 ) ) */
/*-----------------------------------------------------------*/

// 条件编译：仅当满足以下三个条件时才编译此函数
// 1. 启用静态内存分配（configSUPPORT_STATIC_ALLOCATION == 1）
// 2. 启用内核提供静态内存（configKERNEL_PROVIDED_STATIC_MEMORY == 1）
// 3. 未使用MPU内存保护包装（portUSING_MPU_WRAPPERS == 0）
#if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configKERNEL_PROVIDED_STATIC_MEMORY == 1 ) && ( portUSING_MPU_WRAPPERS == 0 ) )

/*
 * 此函数是内核提供的vApplicationGetTimerTaskMemory()实现，
 * 用于提供定时器服务任务所需的内存（TCB和栈）。当configKERNEL_PROVIDED_STATIC_MEMORY设为1时启用。
 * 应用程序可通过将configKERNEL_PROVIDED_STATIC_MEMORY设为0或不定义，
 * 自行提供vApplicationGetTimerTaskMemory()的实现。
 */
    void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer,  // 输出：定时器任务TCB的静态内存指针
                                         StackType_t ** ppxTimerTaskStackBuffer,  // 输出：定时器任务栈的静态内存指针
                                         configSTACK_DEPTH_TYPE * puxTimerTaskStackSize )  // 输出：定时器任务栈的深度（大小）
    {
        // 静态分配定时器服务任务的TCB（任务控制块）：内存生命周期与程序一致，不随函数退出释放
        static StaticTask_t xTimerTaskTCB;
        // 静态分配定时器服务任务的栈：大小由configTIMER_TASK_STACK_DEPTH配置
        static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

        // 将静态TCB的地址通过输出参数返回给内核（内核用此内存初始化任务）
        *ppxTimerTaskTCBBuffer = &( xTimerTaskTCB );
        // 将静态栈的起始地址通过输出参数返回给内核（内核用此内存作为任务栈）
        *ppxTimerTaskStackBuffer = &( uxTimerTaskStack[ 0 ] );
        // 将栈的深度（大小）通过输出参数返回给内核（内核确认栈空间是否足够）
        *puxTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    }

#endif /* 条件编译结束 */
/*-----------------------------------------------------------*/

/*
 * Reset the state in this file. This state is normally initialized at start up.
 * This function must be called by the application before restarting the
 * scheduler.
 */
void vTaskResetState( void )
{
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
    }
    #endif /* #if ( INCLUDE_vTaskDelete == 1 ) */

    #if ( configUSE_POSIX_ERRNO == 1 )
    {
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    uxTopReadyPriority = tskIDLE_PRIORITY;
    xSchedulerRunning = pdFALSE;
    xPendedTicks = ( TickType_t ) 0U;

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
    }

    xNumOfOverflows = ( BaseType_t ) 0;
    uxTaskNumber = ( UBaseType_t ) 0U;
    xNextTaskUnblockTime = ( TickType_t ) 0U;

    uxSchedulerSuspended = ( UBaseType_t ) 0U;

    #if ( configGENERATE_RUN_TIME_STATS == 1 )
    {
        for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
        {
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
/*-----------------------------------------------------------*/




